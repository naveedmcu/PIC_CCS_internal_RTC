CCS PCM C Compiler, Version 5.070, 56587               04-Mar-23 21:09

               Filename:   C:\Users\HP\AppData\Roaming\PICC\ex_time.lst

               ROM used:   2919 words (36%)
                           Largest free fragment is 2048
               RAM used:   150 (41%) at main() level
                           195 (53%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   30E
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   05E
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            EX_TIME.C                            //// 
.................... ////                                                                 //// 
.................... ////  Demo of using CCS's time.h standard library with timebase      //// 
.................... ////  drivers.  See time.h for more documentation and CCS provided   //// 
.................... ////  timebase drivers.                                              //// 
.................... ////                                                                 //// 
.................... ////  Look for ** TIMEBASE SELECTION ** in this example, which has   //// 
.................... ////  a series of #if/#elif that allows you to select the timebase   //// 
.................... ////  for time.h.                                                    //// 
.................... ////                                                                 //// 
.................... ////  When running, current time is continously displaed on the      //// 
.................... ////  serial port.  If LCD is on your board, time is also displayed  //// 
.................... ////  over the LCD.  When the program starts, it will ask for        //// 
.................... ////  current date/time over the serial port.                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #include <16F876.h> 
.................... //////////// Standard Header file for the PIC16F876 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
*
0066:  BCF    0C.0
0067:  BCF    0A.3
0068:  BCF    0A.4
0069:  GOTO   02D
.................... #device PIC16F876 
*
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  49
0056:  RETLW  6E
0057:  RETLW  76
0058:  RETLW  61
0059:  RETLW  6C
005A:  RETLW  69
005B:  RETLW  64
005C:  RETLW  00
005D:  RETLW  00
005E:  MOVLW  01
005F:  ADDWF  3F,F
0060:  BTFSC  03.0
0061:  INCF   40,F
0062:  BTFSC  03.2
0063:  INCF   41,F
0064:  BTFSC  03.2
0065:  INCF   42,F
*
006A:  DATA 0D,05
006B:  DATA CD,34
006C:  DATA EE,3A
006D:  DATA F4,32
006E:  DATA 20,14
006F:  DATA B0,16
0070:  DATA B5,1C
0071:  DATA 29,1D
0072:  DATA 20,00
0073:  DATA 0D,05
0074:  DATA C8,37
0075:  DATA 75,39
0076:  DATA 20,14
0077:  DATA B0,16
0078:  DATA B2,19
0079:  DATA 29,1D
007A:  DATA 20,00
007B:  DATA 0D,05
007C:  DATA C4,30
007D:  DATA 79,10
007E:  DATA A8,18
007F:  DATA AD,19
0080:  DATA B1,14
0081:  DATA 3A,10
0082:  DATA 00,01
0083:  DATA 0D,05
0084:  DATA CD,37
0085:  DATA 6E,3A
0086:  DATA 68,10
0087:  DATA A8,18
0088:  DATA AD,18
0089:  DATA B2,14
008A:  DATA 3A,10
008B:  DATA 00,01
008C:  DATA 0D,05
008D:  DATA D9,32
008E:  DATA 61,39
008F:  DATA 20,14
0090:  DATA 65,3C
0091:  DATA 3A,10
0092:  DATA 32,18
0093:  DATA 31,19
0094:  DATA 29,1D
0095:  DATA 20,00
0096:  DATA 0D,05
0097:  DATA 8A,21
0098:  DATA C3,29
0099:  DATA A0,21
009A:  DATA A0,21
009B:  DATA EF,36
009C:  DATA F0,34
009D:  DATA EC,32
009E:  DATA 72,10
009F:  DATA 65,3C
00A0:  DATA 5F,3A
00A1:  DATA E9,36
00A2:  DATA 65,17
00A3:  DATA 63,10
00A4:  DATA 65,3C
00A5:  DATA E1,36
00A6:  DATA 70,36
00A7:  DATA 65,10
00A8:  DATA 73,3A
00A9:  DATA 61,39
00AA:  DATA F4,34
00AB:  DATA EE,33
00AC:  DATA 0D,05
00AD:  DATA 0A,00
*
00C2:  MOVF   0B,W
00C3:  BSF    03.5
00C4:  MOVWF  52
00C5:  BCF    03.5
00C6:  BCF    0B.7
00C7:  BSF    03.5
00C8:  BSF    03.6
00C9:  BSF    0C.7
00CA:  BSF    0C.0
00CB:  NOP
00CC:  NOP
00CD:  BCF    03.6
00CE:  BTFSS  52.7
00CF:  GOTO   0D3
00D0:  BCF    03.5
00D1:  BSF    0B.7
00D2:  BSF    03.5
00D3:  BCF    03.5
00D4:  BSF    03.6
00D5:  MOVF   0C,W
00D6:  ANDLW  7F
00D7:  BTFSC  03.2
00D8:  GOTO   136
00D9:  BSF    03.5
00DA:  BCF    03.6
00DB:  MOVWF  52
00DC:  BCF    03.5
00DD:  BSF    03.6
00DE:  MOVF   0D,W
00DF:  BSF    03.5
00E0:  BCF    03.6
00E1:  MOVWF  53
00E2:  BCF    03.5
00E3:  BSF    03.6
00E4:  MOVF   0F,W
00E5:  BSF    03.5
00E6:  BCF    03.6
00E7:  MOVWF  54
00E8:  MOVF   52,W
00E9:  BCF    03.5
00EA:  BTFSS  0C.4
00EB:  GOTO   0EA
00EC:  MOVWF  19
00ED:  BSF    03.5
00EE:  MOVF   53,W
00EF:  BCF    03.5
00F0:  BSF    03.6
00F1:  MOVWF  0D
00F2:  BSF    03.5
00F3:  BCF    03.6
00F4:  MOVF   54,W
00F5:  BCF    03.5
00F6:  BSF    03.6
00F7:  MOVWF  0F
00F8:  BCF    03.6
00F9:  MOVF   0B,W
00FA:  BSF    03.5
00FB:  MOVWF  55
00FC:  BCF    03.5
00FD:  BCF    0B.7
00FE:  BSF    03.5
00FF:  BSF    03.6
0100:  BSF    0C.7
0101:  BSF    0C.0
0102:  NOP
0103:  NOP
0104:  BCF    03.6
0105:  BTFSS  55.7
0106:  GOTO   10A
0107:  BCF    03.5
0108:  BSF    0B.7
0109:  BSF    03.5
010A:  BCF    03.5
010B:  BSF    03.6
010C:  RLF    0C,W
010D:  RLF    0E,W
010E:  ANDLW  7F
010F:  BTFSC  03.2
0110:  GOTO   136
0111:  BSF    03.5
0112:  BCF    03.6
0113:  MOVWF  52
0114:  BCF    03.5
0115:  BSF    03.6
0116:  MOVF   0D,W
0117:  BSF    03.5
0118:  BCF    03.6
0119:  MOVWF  53
011A:  BCF    03.5
011B:  BSF    03.6
011C:  MOVF   0F,W
011D:  BSF    03.5
011E:  BCF    03.6
011F:  MOVWF  54
0120:  MOVF   52,W
0121:  BCF    03.5
0122:  BTFSS  0C.4
0123:  GOTO   122
0124:  MOVWF  19
0125:  BSF    03.5
0126:  MOVF   53,W
0127:  BCF    03.5
0128:  BSF    03.6
0129:  MOVWF  0D
012A:  BSF    03.5
012B:  BCF    03.6
012C:  MOVF   54,W
012D:  BCF    03.5
012E:  BSF    03.6
012F:  MOVWF  0F
0130:  INCF   0D,F
0131:  BTFSC  03.2
0132:  INCF   0F,F
0133:  BCF    03.6
0134:  GOTO   0C2
0135:  BSF    03.6
0136:  BCF    03.6
0137:  BSF    0A.3
0138:  BCF    0A.4
0139:  GOTO   358 (RETURN)
*
020E:  BTFSC  03.1
020F:  GOTO   213
0210:  MOVLW  10
0211:  MOVWF  04
0212:  BSF    03.7
0213:  BSF    03.5
0214:  MOVF   68,W
0215:  XORWF  6C,W
0216:  ANDLW  80
0217:  BCF    03.5
0218:  BSF    03.6
0219:  MOVWF  15
021A:  BSF    03.5
021B:  BCF    03.6
021C:  BTFSS  68.7
021D:  GOTO   229
021E:  COMF   65,F
021F:  COMF   66,F
0220:  COMF   67,F
0221:  COMF   68,F
0222:  INCF   65,F
0223:  BTFSC  03.2
0224:  INCF   66,F
0225:  BTFSC  03.2
0226:  INCF   67,F
0227:  BTFSC  03.2
0228:  INCF   68,F
0229:  BTFSS  6C.7
022A:  GOTO   236
022B:  COMF   69,F
022C:  COMF   6A,F
022D:  COMF   6B,F
022E:  COMF   6C,F
022F:  INCF   69,F
0230:  BTFSC  03.2
0231:  INCF   6A,F
0232:  BTFSC  03.2
0233:  INCF   6B,F
0234:  BTFSC  03.2
0235:  INCF   6C,F
0236:  CLRF   77
0237:  CLRF   78
0238:  CLRF   79
0239:  CLRF   7A
023A:  BCF    03.5
023B:  BSF    03.6
023C:  CLRF   10
023D:  CLRF   11
023E:  CLRF   12
023F:  CLRF   13
0240:  BSF    03.5
0241:  BCF    03.6
0242:  MOVF   6C,W
0243:  IORWF  6B,W
0244:  IORWF  6A,W
0245:  IORWF  69,W
0246:  BTFSC  03.2
0247:  GOTO   2AA
0248:  MOVLW  20
0249:  BCF    03.5
024A:  BSF    03.6
024B:  MOVWF  14
024C:  BCF    03.0
024D:  BSF    03.5
024E:  BCF    03.6
024F:  RLF    65,F
0250:  RLF    66,F
0251:  RLF    67,F
0252:  RLF    68,F
0253:  BCF    03.5
0254:  BSF    03.6
0255:  RLF    10,F
0256:  RLF    11,F
0257:  RLF    12,F
0258:  RLF    13,F
0259:  BSF    03.5
025A:  BCF    03.6
025B:  MOVF   6C,W
025C:  BCF    03.5
025D:  BSF    03.6
025E:  SUBWF  13,W
025F:  BTFSS  03.2
0260:  GOTO   277
0261:  BSF    03.5
0262:  BCF    03.6
0263:  MOVF   6B,W
0264:  BCF    03.5
0265:  BSF    03.6
0266:  SUBWF  12,W
0267:  BTFSS  03.2
0268:  GOTO   277
0269:  BSF    03.5
026A:  BCF    03.6
026B:  MOVF   6A,W
026C:  BCF    03.5
026D:  BSF    03.6
026E:  SUBWF  11,W
026F:  BTFSS  03.2
0270:  GOTO   277
0271:  BSF    03.5
0272:  BCF    03.6
0273:  MOVF   69,W
0274:  BCF    03.5
0275:  BSF    03.6
0276:  SUBWF  10,W
0277:  BTFSS  03.0
0278:  GOTO   2A2
0279:  BSF    03.5
027A:  BCF    03.6
027B:  MOVF   69,W
027C:  BCF    03.5
027D:  BSF    03.6
027E:  SUBWF  10,F
027F:  BSF    03.5
0280:  BCF    03.6
0281:  MOVF   6A,W
0282:  BTFSS  03.0
0283:  INCFSZ 6A,W
0284:  GOTO   286
0285:  GOTO   28B
0286:  BCF    03.5
0287:  BSF    03.6
0288:  SUBWF  11,F
0289:  BSF    03.5
028A:  BCF    03.6
028B:  MOVF   6B,W
028C:  BTFSS  03.0
028D:  INCFSZ 6B,W
028E:  GOTO   290
028F:  GOTO   295
0290:  BCF    03.5
0291:  BSF    03.6
0292:  SUBWF  12,F
0293:  BSF    03.5
0294:  BCF    03.6
0295:  MOVF   6C,W
0296:  BTFSS  03.0
0297:  INCFSZ 6C,W
0298:  GOTO   29A
0299:  GOTO   29F
029A:  BCF    03.5
029B:  BSF    03.6
029C:  SUBWF  13,F
029D:  BSF    03.5
029E:  BCF    03.6
029F:  BSF    03.0
02A0:  BCF    03.5
02A1:  BSF    03.6
02A2:  RLF    77,F
02A3:  RLF    78,F
02A4:  RLF    79,F
02A5:  RLF    7A,F
02A6:  DECFSZ 14,F
02A7:  GOTO   24C
02A8:  BSF    03.5
02A9:  BCF    03.6
02AA:  BCF    03.5
02AB:  BSF    03.6
02AC:  BTFSS  15.7
02AD:  GOTO   2B9
02AE:  COMF   77,F
02AF:  COMF   78,F
02B0:  COMF   79,F
02B1:  COMF   7A,F
02B2:  INCF   77,F
02B3:  BTFSC  03.2
02B4:  INCF   78,F
02B5:  BTFSC  03.2
02B6:  INCF   79,F
02B7:  BTFSC  03.2
02B8:  INCF   7A,F
02B9:  MOVF   10,W
02BA:  MOVWF  00
02BB:  INCF   04,F
02BC:  MOVF   11,W
02BD:  MOVWF  00
02BE:  INCF   04,F
02BF:  MOVF   12,W
02C0:  MOVWF  00
02C1:  INCF   04,F
02C2:  MOVF   13,W
02C3:  MOVWF  00
02C4:  BCF    03.6
02C5:  RETURN
02C6:  CLRF   78
02C7:  CLRF   79
02C8:  CLRF   77
02C9:  CLRF   7A
02CA:  BSF    03.5
02CB:  MOVF   64,W
02CC:  BTFSS  03.2
02CD:  GOTO   2D1
02CE:  MOVF   63,W
02CF:  BTFSC  03.2
02D0:  GOTO   2EB
02D1:  MOVLW  10
02D2:  MOVWF  65
02D3:  BCF    03.0
02D4:  RLF    61,F
02D5:  RLF    62,F
02D6:  RLF    77,F
02D7:  RLF    7A,F
02D8:  MOVF   64,W
02D9:  SUBWF  7A,W
02DA:  BTFSS  03.2
02DB:  GOTO   2DE
02DC:  MOVF   63,W
02DD:  SUBWF  77,W
02DE:  BTFSS  03.0
02DF:  GOTO   2E7
02E0:  MOVF   63,W
02E1:  SUBWF  77,F
02E2:  BTFSS  03.0
02E3:  DECF   7A,F
02E4:  MOVF   64,W
02E5:  SUBWF  7A,F
02E6:  BSF    03.0
02E7:  RLF    78,F
02E8:  RLF    79,F
02E9:  DECFSZ 65,F
02EA:  GOTO   2D3
02EB:  BCF    03.5
02EC:  RETURN
*
032B:  MOVLW  20
032C:  BSF    03.5
032D:  MOVWF  6D
032E:  CLRF   69
032F:  CLRF   6A
0330:  CLRF   6B
0331:  CLRF   6C
0332:  MOVF   64,W
0333:  MOVWF  7A
0334:  MOVF   63,W
0335:  MOVWF  79
0336:  MOVF   62,W
0337:  MOVWF  78
0338:  MOVF   61,W
0339:  MOVWF  77
033A:  BCF    03.0
033B:  BTFSS  77.0
033C:  GOTO   34B
033D:  MOVF   65,W
033E:  ADDWF  69,F
033F:  MOVF   66,W
0340:  BTFSC  03.0
0341:  INCFSZ 66,W
0342:  ADDWF  6A,F
0343:  MOVF   67,W
0344:  BTFSC  03.0
0345:  INCFSZ 67,W
0346:  ADDWF  6B,F
0347:  MOVF   68,W
0348:  BTFSC  03.0
0349:  INCFSZ 68,W
034A:  ADDWF  6C,F
034B:  RRF    6C,F
034C:  RRF    6B,F
034D:  RRF    6A,F
034E:  RRF    69,F
034F:  RRF    7A,F
0350:  RRF    79,F
0351:  RRF    78,F
0352:  RRF    77,F
0353:  DECFSZ 6D,F
0354:  GOTO   33A
0355:  BCF    03.5
0356:  RETURN
*
05E6:  MOVLW  10
05E7:  MOVWF  63
05E8:  CLRF   77
05E9:  CLRF   7A
05EA:  RRF    60,F
05EB:  RRF    5F,F
05EC:  BTFSS  03.0
05ED:  GOTO   5F4
05EE:  MOVF   61,W
05EF:  ADDWF  77,F
05F0:  BTFSC  03.0
05F1:  INCF   7A,F
05F2:  MOVF   62,W
05F3:  ADDWF  7A,F
05F4:  RRF    7A,F
05F5:  RRF    77,F
05F6:  RRF    79,F
05F7:  RRF    78,F
05F8:  DECFSZ 63,F
05F9:  GOTO   5EA
*
0638:  MOVF   31,W
0639:  MOVWF  04
063A:  BCF    03.7
063B:  BTFSC  32.0
063C:  BSF    03.7
063D:  BSF    03.6
063E:  MOVF   1F,W
063F:  MOVWF  00
0640:  INCF   04,F
0641:  CLRF   00
0642:  BCF    03.6
0643:  INCF   31,F
0644:  BTFSC  03.2
0645:  INCF   32,F
0646:  RETURN
0647:  BSF    03.6
0648:  MOVF   19,W
0649:  CLRF   78
064A:  SUBWF  18,W
064B:  BTFSC  03.0
064C:  GOTO   650
064D:  MOVF   18,W
064E:  MOVWF  77
064F:  GOTO   65C
0650:  CLRF   77
0651:  MOVLW  08
0652:  MOVWF  1A
0653:  RLF    18,F
0654:  RLF    77,F
0655:  MOVF   19,W
0656:  SUBWF  77,W
0657:  BTFSC  03.0
0658:  MOVWF  77
0659:  RLF    78,F
065A:  DECFSZ 1A,F
065B:  GOTO   653
065C:  BCF    03.6
065D:  RETURN
065E:  MOVF   78,W
065F:  BSF    03.6
0660:  MOVF   16,W
0661:  MOVWF  18
0662:  MOVLW  64
0663:  MOVWF  19
0664:  BCF    03.6
0665:  CALL   647
0666:  MOVF   77,W
0667:  BSF    03.6
0668:  MOVWF  16
0669:  MOVF   78,W
066A:  MOVLW  30
066B:  BTFSS  03.2
066C:  GOTO   674
066D:  BTFSS  17.1
066E:  GOTO   67D
066F:  BTFSC  17.3
0670:  GOTO   67D
0671:  BTFSC  17.4
0672:  MOVLW  20
0673:  GOTO   677
0674:  BCF    17.3
0675:  BCF    17.4
0676:  BSF    17.0
0677:  ADDWF  78,F
0678:  MOVF   78,W
0679:  MOVWF  1F
067A:  BCF    03.6
067B:  CALL   638
067C:  BSF    03.6
067D:  MOVF   16,W
067E:  MOVWF  18
067F:  MOVLW  0A
0680:  MOVWF  19
0681:  BCF    03.6
0682:  CALL   647
0683:  MOVF   77,W
0684:  BSF    03.6
0685:  MOVWF  16
0686:  MOVF   78,W
0687:  MOVLW  30
0688:  BTFSS  03.2
0689:  GOTO   690
068A:  BTFSC  17.3
068B:  GOTO   696
068C:  BTFSS  17.0
068D:  GOTO   696
068E:  BTFSC  17.4
068F:  MOVLW  20
0690:  ADDWF  78,F
0691:  MOVF   78,W
0692:  MOVWF  1F
0693:  BCF    03.6
0694:  CALL   638
0695:  BSF    03.6
0696:  MOVLW  30
0697:  ADDWF  16,F
0698:  MOVF   16,W
0699:  MOVWF  1F
069A:  BCF    03.6
069B:  CALL   638
069C:  RETURN
069D:  MOVF   00,F
069E:  BTFSC  03.2
069F:  GOTO   6BA
06A0:  BSF    03.5
06A1:  CLRF   57
06A2:  MOVF   04,W
06A3:  MOVWF  56
06A4:  BCF    57.0
06A5:  BTFSC  03.7
06A6:  BSF    57.0
06A7:  MOVF   00,W
06A8:  BCF    03.5
06A9:  BTFSS  0C.4
06AA:  GOTO   6A9
06AB:  MOVWF  19
06AC:  BSF    03.5
06AD:  MOVF   56,W
06AE:  MOVWF  04
06AF:  BCF    03.7
06B0:  BTFSC  57.0
06B1:  BSF    03.7
06B2:  INCF   04,F
06B3:  BTFSS  03.2
06B4:  GOTO   6B8
06B5:  BCF    03.5
06B6:  INCF   05,F
06B7:  BSF    03.5
06B8:  BCF    03.5
06B9:  GOTO   69D
06BA:  BSF    0A.3
06BB:  BCF    0A.4
06BC:  GOTO   3B0 (RETURN)
06BD:  BTFSC  03.1
06BE:  GOTO   6C2
06BF:  MOVLW  EA
06C0:  MOVWF  04
06C1:  BCF    03.7
06C2:  CLRF   77
06C3:  CLRF   78
06C4:  CLRF   79
06C5:  CLRF   7A
06C6:  BSF    03.5
06C7:  CLRF   6A
06C8:  CLRF   6B
06C9:  CLRF   6C
06CA:  CLRF   6D
06CB:  MOVF   69,W
06CC:  IORWF  68,W
06CD:  IORWF  67,W
06CE:  IORWF  66,W
06CF:  BTFSC  03.2
06D0:  GOTO   701
06D1:  MOVLW  20
06D2:  MOVWF  6E
06D3:  BCF    03.0
06D4:  RLF    62,F
06D5:  RLF    63,F
06D6:  RLF    64,F
06D7:  RLF    65,F
06D8:  RLF    6A,F
06D9:  RLF    6B,F
06DA:  RLF    6C,F
06DB:  RLF    6D,F
06DC:  MOVF   69,W
06DD:  SUBWF  6D,W
06DE:  BTFSS  03.2
06DF:  GOTO   6EA
06E0:  MOVF   68,W
06E1:  SUBWF  6C,W
06E2:  BTFSS  03.2
06E3:  GOTO   6EA
06E4:  MOVF   67,W
06E5:  SUBWF  6B,W
06E6:  BTFSS  03.2
06E7:  GOTO   6EA
06E8:  MOVF   66,W
06E9:  SUBWF  6A,W
06EA:  BTFSS  03.0
06EB:  GOTO   6FB
06EC:  MOVF   66,W
06ED:  SUBWF  6A,F
06EE:  MOVF   67,W
06EF:  BTFSS  03.0
06F0:  INCFSZ 67,W
06F1:  SUBWF  6B,F
06F2:  MOVF   68,W
06F3:  BTFSS  03.0
06F4:  INCFSZ 68,W
06F5:  SUBWF  6C,F
06F6:  MOVF   69,W
06F7:  BTFSS  03.0
06F8:  INCFSZ 69,W
06F9:  SUBWF  6D,F
06FA:  BSF    03.0
06FB:  RLF    77,F
06FC:  RLF    78,F
06FD:  RLF    79,F
06FE:  RLF    7A,F
06FF:  DECFSZ 6E,F
0700:  GOTO   6D3
0701:  MOVF   6A,W
0702:  MOVWF  00
0703:  INCF   04,F
0704:  MOVF   6B,W
0705:  MOVWF  00
0706:  INCF   04,F
0707:  MOVF   6C,W
0708:  MOVWF  00
0709:  INCF   04,F
070A:  MOVF   6D,W
070B:  MOVWF  00
070C:  BCF    03.5
070D:  RETURN
070E:  MOVF   04,W
070F:  BSF    03.5
0710:  MOVWF  5A
0711:  MOVLW  3B
0712:  MOVWF  61
0713:  MOVLW  9A
0714:  MOVWF  60
0715:  MOVLW  CA
0716:  MOVWF  5F
0717:  CLRF   5E
0718:  MOVLW  0A
0719:  MOVWF  5C
071A:  BSF    03.1
071B:  MOVLW  D6
071C:  MOVWF  04
071D:  BCF    03.7
071E:  MOVF   59,W
071F:  MOVWF  65
0720:  MOVF   58,W
0721:  MOVWF  64
0722:  MOVF   57,W
0723:  MOVWF  63
0724:  MOVF   56,W
0725:  MOVWF  62
0726:  MOVF   61,W
0727:  MOVWF  69
0728:  MOVF   60,W
0729:  MOVWF  68
072A:  MOVF   5F,W
072B:  MOVWF  67
072C:  MOVF   5E,W
072D:  MOVWF  66
072E:  BCF    03.5
072F:  CALL   6BD
0730:  MOVF   78,W
0731:  MOVF   77,F
0732:  BTFSS  03.2
0733:  GOTO   74B
0734:  BSF    03.5
0735:  MOVF   5C,W
0736:  XORLW  01
0737:  BTFSS  03.2
0738:  GOTO   73B
0739:  BCF    03.5
073A:  GOTO   74B
073B:  MOVF   5A,W
073C:  BTFSC  03.2
073D:  GOTO   74D
073E:  ANDLW  0F
073F:  SUBWF  5C,W
0740:  BTFSC  03.2
0741:  GOTO   744
0742:  BTFSC  03.0
0743:  GOTO   755
0744:  BTFSC  5A.7
0745:  GOTO   755
0746:  BTFSC  5A.6
0747:  GOTO   74D
0748:  MOVLW  20
0749:  GOTO   74E
074A:  BCF    03.5
074B:  BSF    03.5
074C:  CLRF   5A
074D:  MOVLW  30
074E:  ADDWF  77,F
074F:  MOVF   77,W
0750:  BCF    03.5
0751:  BTFSS  0C.4
0752:  GOTO   751
0753:  MOVWF  19
0754:  BSF    03.5
0755:  BCF    03.1
0756:  MOVF   61,W
0757:  MOVWF  65
0758:  MOVF   60,W
0759:  MOVWF  64
075A:  MOVF   5F,W
075B:  MOVWF  63
075C:  MOVF   5E,W
075D:  MOVWF  62
075E:  CLRF   69
075F:  CLRF   68
0760:  CLRF   67
0761:  MOVLW  0A
0762:  MOVWF  66
0763:  BCF    03.5
0764:  CALL   6BD
0765:  MOVF   7A,W
0766:  BSF    03.5
0767:  MOVWF  61
0768:  MOVF   79,W
0769:  MOVWF  60
076A:  MOVF   78,W
076B:  MOVWF  5F
076C:  MOVF   77,W
076D:  MOVWF  5E
076E:  DECFSZ 5C,F
076F:  GOTO   71A
0770:  BCF    03.5
0771:  RETURN
*
0A6E:  CLRF   1E
0A6F:  MOVF   04,W
0A70:  MOVWF  1D
0A71:  BCF    1E.0
0A72:  BTFSC  03.7
0A73:  BSF    1E.0
0A74:  SWAPF  17,W
0A75:  IORLW  F0
0A76:  MOVWF  19
0A77:  ADDWF  19,F
0A78:  ADDLW  E2
0A79:  MOVWF  1A
0A7A:  ADDLW  32
0A7B:  MOVWF  1C
0A7C:  MOVF   17,W
0A7D:  ANDLW  0F
0A7E:  ADDWF  1A,F
0A7F:  ADDWF  1A,F
0A80:  ADDWF  1C,F
0A81:  ADDLW  E9
0A82:  MOVWF  1B
0A83:  ADDWF  1B,F
0A84:  ADDWF  1B,F
0A85:  SWAPF  16,W
0A86:  ANDLW  0F
0A87:  ADDWF  1B,F
0A88:  ADDWF  1C,F
0A89:  RLF    1B,F
0A8A:  RLF    1C,F
0A8B:  COMF   1C,F
0A8C:  RLF    1C,F
0A8D:  MOVF   16,W
0A8E:  ANDLW  0F
0A8F:  ADDWF  1C,F
0A90:  RLF    19,F
0A91:  MOVLW  07
0A92:  MOVWF  18
0A93:  MOVLW  0A
0A94:  ADDWF  1C,F
0A95:  DECF   1B,F
0A96:  BTFSS  03.0
0A97:  GOTO   294
0A98:  ADDWF  1B,F
0A99:  DECF   1A,F
0A9A:  BTFSS  03.0
0A9B:  GOTO   298
0A9C:  ADDWF  1A,F
0A9D:  DECF   19,F
0A9E:  BTFSS  03.0
0A9F:  GOTO   29C
0AA0:  ADDWF  19,F
0AA1:  DECF   18,F
0AA2:  BTFSS  03.0
0AA3:  GOTO   2A0
0AA4:  MOVLW  18
0AA5:  MOVWF  04
0AA6:  BSF    03.7
0AA7:  MOVLW  07
0AA8:  ANDWF  1D,W
0AA9:  BCF    1D.6
0AAA:  ADDWF  04,F
0AAB:  MOVLW  1C
0AAC:  SUBWF  04,W
0AAD:  BTFSC  03.2
0AAE:  BSF    1D.6
0AAF:  MOVF   00,W
0AB0:  MOVWF  77
0AB1:  BTFSS  03.2
0AB2:  GOTO   2BB
0AB3:  BTFSC  1D.6
0AB4:  GOTO   2BB
0AB5:  BTFSC  1D.4
0AB6:  GOTO   2D1
0AB7:  BTFSC  1D.3
0AB8:  GOTO   2BB
0AB9:  MOVLW  20
0ABA:  GOTO   2BE
0ABB:  BSF    1D.3
0ABC:  BCF    1D.4
0ABD:  MOVLW  30
0ABE:  ADDWF  77,F
0ABF:  CLRF   17
0AC0:  MOVF   04,W
0AC1:  MOVWF  16
0AC2:  BCF    17.0
0AC3:  BTFSC  03.7
0AC4:  BSF    17.0
0AC5:  MOVF   77,W
0AC6:  MOVWF  1F
0AC7:  BCF    0A.3
0AC8:  BCF    03.6
0AC9:  CALL   638
0ACA:  BSF    0A.3
0ACB:  BSF    03.6
0ACC:  MOVF   16,W
0ACD:  MOVWF  04
0ACE:  BCF    03.7
0ACF:  BTFSC  17.0
0AD0:  BSF    03.7
0AD1:  INCF   04,F
0AD2:  BTFSS  1D.6
0AD3:  GOTO   2AB
....................  
.................... #list 
....................  
.................... #use delay(crystal=20Mhz) 
*
00AE:  MOVLW  D2
00AF:  MOVWF  04
00B0:  BCF    03.7
00B1:  MOVF   00,W
00B2:  BTFSC  03.2
00B3:  GOTO   0C1
00B4:  MOVLW  06
00B5:  MOVWF  78
00B6:  CLRF   77
00B7:  DECFSZ 77,F
00B8:  GOTO   0B7
00B9:  DECFSZ 78,F
00BA:  GOTO   0B6
00BB:  MOVLW  7B
00BC:  MOVWF  77
00BD:  DECFSZ 77,F
00BE:  GOTO   0BD
00BF:  DECFSZ 00,F
00C0:  GOTO   0B4
00C1:  RETURN
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, stream=STREAM_USER_UART) 
.................... #fuses NOWDT 
.................... //!#define GET_RTC_TICKS 
.................... //!#use timer(TIMER=0,TICK=10ms, BITS=16, ISR) 
.................... //!#define GET_RTC_TICKS()    get_ticks() 
.................... //!#define CLOCKS_PER_SECOND  TICKS_PER_SECOND 
.................... //!#define INIT_RTC_TICKS()   enable_interrupts(GLOBAL) 
....................  
.................... #ifndef BUTTON_PRESSED 
....................    // if your hardware doesn't have a button, then everytime you power up 
....................    // it will ask you to init the clock. 
....................    #define BUTTON_PRESSED()   (TRUE) 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0B3F:  CLRF   2B
0B40:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <input.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                             input.c                               //// 
.................... ////                                                                   //// 
.................... //// Routines for reading user input over an RS232 stream.  User input //// 
.................... //// is in ASCII form and converted to requested binary or float       //// 
.................... //// format.                                                           //// 
.................... ////                                                                   //// 
.................... //// If STREAM_SERIAL_INPUT is defined, these routines will read from  //// 
.................... //// that serial stream.  If not, uses the last #use rs232().          //// 
.................... ////                                                                   //// 
.................... //// Some of these routines are not available unless you #include      //// 
.................... //// string.h and stdlib.h                                             //// 
.................... ////                                                                   //// 
.................... ////  int8 gethex() - read 2 char hex value from serial                //// 
.................... ////                                                                   //// 
.................... ////  get_string(s, max) - read max chars from serial and save to s    //// 
.................... ////                                                                   //// 
.................... ////  get_stringEdit(s, max) - similar to get_string(), but first it   //// 
.................... ////     displays current string in s, allowing you to edit it.        //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8() -                                              //// 
.................... ////  int16 = get_Int16() -                                            //// 
.................... ////  int32 = get_Int32() -                                            //// 
.................... ////  float = get_float() -                                            //// 
.................... ////     Read value from serial.                                       //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8Edit(old) -                                       //// 
.................... ////  int16 = get_Int16Edit(old) -                                     //// 
.................... ////  int32 = get_Int32Edit(old) -                                     //// 
.................... ////  float = get_floatEdit(old) -                                     //// 
.................... ////     Similar to get_Int*() routines documented above, but first    //// 
.................... ////     it displays old value allowing you to edit it.                //// 
.................... ////                                                                   //// 
.................... ////  int = get_int() -                                                //// 
.................... ////  long = get_long() -                                              //// 
.................... ////     Simlar to get_Int*() documented above, but return 'int' and   //// 
.................... ////     'long' datatypes.  The size of these datatypes depends on     //// 
.................... ////     the PIC architecture and compiler configuration.              //// 
.................... ////                                                                   //// 
.................... ////  int = get_intEdit(old) -                                         //// 
.................... ////  long = get_longEdit(old) -                                       //// 
.................... ////     Similar to get_int() and get_long() documented above,         //// 
.................... ////     but first it displays old value allowing you to edit it.      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __INPUT_C__ 
.................... #define __INPUT_C__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #ifndef InputKbhit 
....................    #if defined(STREAM_SERIAL_INPUT) 
....................       #define InputKbhit()    kbhit(STREAM_SERIAL_INPUT) 
....................    #else 
....................       #define InputKbhit()    kbhit() 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef InputPutc 
....................    #if defined(STREAM_SERIAL_INPUT) 
....................       #define InputPutc(c)    fputc(c, STREAM_SERIAL_INPUT) 
....................    #else 
....................       #define InputPutc(c)    putc(c) 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef InputGetc 
....................    #if defined(STREAM_SERIAL_INPUT) 
....................       #define InputGetc()    fgetc(STREAM_SERIAL_INPUT) 
....................    #else 
....................       #define InputGetc()    getc() 
....................    #endif 
.................... #endif 
....................  
.................... unsigned int8 gethex1() { 
....................    char digit; 
....................  
....................    digit = InputGetc(); 
....................  
....................    InputPutc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... unsigned int8 gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    max-=2; 
....................    len=0; 
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... #ifdef _STRING 
.................... void get_stringEdit(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    len = strlen(s); 
....................  
....................    if (len) 
....................    { 
....................      #if defined(STREAM_SERIAL_INPUT) 
....................       fprintf(STREAM_SERIAL_INPUT, "%s", s); 
....................      #else 
....................       printf("%s", s); 
....................      #endif 
....................    } 
....................  
....................    max-=2; 
....................  
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
.................... #endif 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... signed int8 get_Int8(void) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int8 get_Int8Edit(signed int8 old) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   sprintf(s, "%d", old); 
....................   get_stringEdit(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... signed int16 get_Int16(void) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int16 get_Int16Edit(signed int16 old) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... signed int32 get_Int32(void) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int32 get_Int32Edit(signed int32 old) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... float get_floatEdit(float old) { 
....................   char s[20]; 
....................   float f; 
....................  
....................   sprintf(s, "%f", old); 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................    #define get_int()       get_Int16() 
....................    #define get_intEdit()   get_Int16Edit() 
....................    #define get_long()      get_Int32() 
....................    #define get_longEdit()  get_Int32Edit() 
.................... #else 
....................    #define get_int()       get_Int8() 
....................    #define get_intEdit()   get_Int8Edit() 
....................    #define get_long()      get_Int16() 
....................    #define get_longEdit()  get_Int16Edit() 
.................... #endif 
....................  
.................... #endif   //_STDLIB 
....................  
.................... #endif   //__INPUT_C__ 
....................  
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() and asctime() have another optional input parameter which /// 
.................... ///     is the pointer to where to save the result string.                /// 
.................... ///     Normally ctime() and asctime() write the output to a globally     /// 
.................... ///     allocated string and return a pointer to this string.  By using   /// 
.................... ///     this optional extra function parameter, you can store the         /// 
.................... ///     result string into a specified location.                          /// 
.................... ///   * The output string of ctime() and asctime() are not statically     /// 
.................... ///     allocated.  That means any other code that runs after ctime()     /// 
.................... ///     or asctime() can corrupt the result value.  Either perform        /// 
.................... ///     a string copy of the result into a new location, or use the       /// 
.................... ///     optional parameter of these functions to store the result         /// 
....................  
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///   * Added timeasc(), which converts a string to a time_t.  It is      /// 
.................... ///      basically the reverse of asctime().  Returns TRUE if successful  /// 
.................... ///      conversion, FALSE if not because format is wrong.                /// 
.................... ///   * Added TIME_T_USES_2010.  Normally time_t is number of seconds     /// 
.................... ///      since January 1 1970.  However, if time_t is a 32bit number this /// 
.................... ///      value will rollover sometime in 2032.  If TIME_T_USES_2010 is    /// 
.................... ///      defined then time_t is number of seconds since January 1 2010,   /// 
.................... ///      and a 32bit time_t won't rollover until 2072.   Most modern      /// 
.................... ///      operating systems (like Windows and Linux) uses a 64bit time_t   /// 
.................... ///      so they aren't effected.  If you are interfacing with another    /// 
.................... ///      system that uses a normal time_t, then that system will need to  /// 
.................... ///      add 1262304000 to the value coming from this library.            /// 
.................... ///      To enable this feature, then #define TIME_T_USES_2010            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... /// VERSION HISTORY                                                     /// 
.................... ///                                                                     /// 
.................... /// June 9 2015:                                                        /// 
.................... ///   Fixed the struct_tm typedef so 'struct tm' would be legal         /// 
.................... ///      syntax.                                                        /// 
.................... ///   The parameters that CCS added to asctime() and ctime() are now    /// 
.................... ///      optional.                                                      /// 
.................... ///   Fixed a bug where tm_mday was sometimes off by 1 day.             /// 
.................... ///                                                                     /// 
.................... /// September 25 2014:                                                  /// 
.................... ///   Cleaned up documentation.                                         /// 
.................... ///   Added timeasc().                                                  /// 
.................... ///   Added TIME_T_USES_2010 compile time option.                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct tm 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (1-31) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* returns number of ticks incremented at CLOCKS_PER_SECOND rate.  This 
....................    function must be provided by the library of your timebase */ 
.................... clock_t clock(void); 
....................  
.................... /* returns time in seconds since January 1 1970 (or January 1 2010 if  
....................    TIME_T_USES_2010 is being used).  This function must be provided by the 
....................    library of your timebase.  For example, see CCS's ds1305.c driver. */ 
.................... time_t time(time_t * timer); 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier); 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime(struct_tm * timeptr, char *szTime = 0); 
....................  
.................... /* the inverse of asctime().  you can skip the wday portion of the string, and 
....................    then this function will not populate the tm_wday in pTm.  If you do skip 
....................    the wday portion of the string, then you can use localtime(mktime()) to 
....................    populate tm_wday with the correct value based on the date.  if pTm is 
....................    NULL it won't save result, but function will still return TRUE or FALSE. 
....................    Function returns TRUE if the format of the input string is valid. */ 
.................... int1 timeasc(struct_tm *pTm, char *szTime); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime(time_t * timer, char *szTime = 0); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime ( time_t * timer ); 
.................... #define gmtime(t) localtime(t) 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTime(struct_tm * nTime); 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTimeSec(time_t sTime); 
....................  
.................... /* Get the time of your system.  This is similar to the standard time() 
....................    function, but this returns directly to a struct_tm.  Since most RTC's work 
....................    with a structure similar to struct_tm, this may be more effecient to use 
....................    than time().   This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void GetTime(struct_tm *pRetTm); 
....................  
.................... /* Initialize your timebase. This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
.................... #include <rtcticks.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                            rtcticks.c                             //// 
.................... ////                                                                   //// 
.................... //// Using the #USE TIMER() directive, provides a time base and        //// 
.................... //// the functions needed for a time.h compatable driver.  See time.h  //// 
.................... //// for documentation of the time.h library.                          //// 
.................... ////                                                                   //// 
.................... //// Options for #USE TIMER:                                           //// 
.................... //// TIMER=x : which PIC timer to use                                  //// 
.................... //// TICK=xx : the desired time for 1 tick - units of s, ms, us, ns    //// 
.................... //// BITS=x  : size of value returned by get_ticks() and used by       //// 
.................... ////           set_ticks(). 8 for 8 bits, 16 for 16 bits, 32 for 32bits//// 
.................... //// ISR   : timer's interrupt used to update tick timer. GLOBAL       //// 
.................... ////         INTERRUPT MUST BE ENABLED BY MAIN PROGRAM BEFORE USE.     //// 
.................... //// NOISR : get_ticks() updates tick timer. get_ticks() MUST BE       //// 
.................... ////         CALLED MORE OFTEN THAN THE TIMER'S OVERFLOW RATE.         //// 
.................... ////         Interrupt need not be enabled for this mode.              //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// Alternately you can provide your own Tick system if you override  //// 
.................... //// the GET_RTC_TICKS and CLOCKS_PER_SECOND macro before including    //// 
.................... //// this file.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __RTCTICKS_C__ 
.................... #define __RTCTICKS_C__ 
....................  
.................... #include <time.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              time.c                                 /// 
.................... ///                                                                     /// 
.................... /// Contains common time routines that can be used by several           /// 
.................... /// timebases, and the runtime code needed for time.h.                  /// 
.................... ///                                                                     /// 
.................... /// See time.h for documentation.                                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_C__ 
.................... #define __TIME_C__ 
....................  
.................... /* Returns the number of days in a given month, leap year dependent 
....................  */ 
.................... static unsigned int8 DaysInMonth(unsigned int8 month, int1 IsLeapYear) 
.................... { 
....................    switch(month) 
*
02ED:  BSF    03.5
02EE:  MOVF   5E,W
02EF:  XORLW  00
02F0:  BCF    03.5
02F1:  BTFSC  03.2
02F2:  GOTO   315
02F3:  XORLW  02
02F4:  BTFSC  03.2
02F5:  GOTO   315
02F6:  XORLW  06
02F7:  BTFSC  03.2
02F8:  GOTO   315
02F9:  XORLW  02
02FA:  BTFSC  03.2
02FB:  GOTO   315
02FC:  XORLW  01
02FD:  BTFSC  03.2
02FE:  GOTO   315
02FF:  XORLW  0E
0300:  BTFSC  03.2
0301:  GOTO   315
0302:  XORLW  02
0303:  BTFSC  03.2
0304:  GOTO   315
0305:  XORLW  0A
0306:  BTFSC  03.2
0307:  GOTO   318
0308:  XORLW  02
0309:  BTFSC  03.2
030A:  GOTO   325
030B:  XORLW  06
030C:  BTFSC  03.2
030D:  GOTO   325
030E:  XORLW  0D
030F:  BTFSC  03.2
0310:  GOTO   325
0311:  XORLW  02
0312:  BTFSC  03.2
0313:  GOTO   325
0314:  GOTO   328
....................    { 
....................       case JANUARY: 
....................       case MARCH: 
....................       case MAY: 
....................       case JULY: 
....................       case AUGUST: 
....................       case OCTOBER: 
....................       case DECEMBER: 
....................          return 31; 
0315:  MOVLW  1F
0316:  MOVWF  78
0317:  GOTO   32A
....................  
....................       case FEBRUARY: 
....................          if(IsLeapYear) 
0318:  BSF    03.5
0319:  MOVF   5F,F
031A:  BTFSC  03.2
031B:  GOTO   321
....................             return 29;             
031C:  MOVLW  1D
031D:  MOVWF  78
031E:  BCF    03.5
031F:  GOTO   32A
0320:  BSF    03.5
....................          return 28; 
0321:  MOVLW  1C
0322:  MOVWF  78
0323:  BCF    03.5
0324:  GOTO   32A
....................  
....................       case APRIL: 
....................       case JUNE: 
....................       case SEPTEMBER: 
....................       case NOVEMBER: 
....................          return 30; 
0325:  MOVLW  1E
0326:  MOVWF  78
0327:  GOTO   32A
....................        
....................       // error 
....................       default: 
....................          return 0; 
0328:  MOVLW  00
0329:  MOVWF  78
....................    } 
032A:  RETURN
.................... }  
....................  
.................... /* Formats a given week day (as an integer) to a string 
....................  */ 
.................... static void WeekdayAbbreviations(unsigned int8 day, char* wString) 
.................... { 
....................    switch(day) 
*
0810:  MOVF   11,W
0811:  XORLW  00
0812:  BCF    03.6
0813:  BTFSC  03.2
0814:  GOTO   028
0815:  XORLW  01
0816:  BTFSC  03.2
0817:  GOTO   039
0818:  XORLW  03
0819:  BTFSC  03.2
081A:  GOTO   04A
081B:  XORLW  01
081C:  BTFSC  03.2
081D:  GOTO   05B
081E:  XORLW  07
081F:  BTFSC  03.2
0820:  GOTO   06C
0821:  XORLW  01
0822:  BTFSC  03.2
0823:  GOTO   07D
0824:  XORLW  03
0825:  BTFSC  03.2
0826:  GOTO   08E
0827:  GOTO   0A0
....................    { 
....................       case SUNDAY: 
....................       memcpy(wString,"Sun\0",4); 
0828:  BSF    03.6
0829:  MOVF   12,W
082A:  MOVWF  04
082B:  BCF    03.7
082C:  BTFSC  13.0
082D:  BSF    03.7
082E:  MOVLW  53
082F:  MOVWF  00
0830:  INCF   04,F
0831:  MOVLW  75
0832:  MOVWF  00
0833:  INCF   04,F
0834:  MOVLW  6E
0835:  MOVWF  00
0836:  INCF   04,F
0837:  CLRF   00
....................       break; 
0838:  GOTO   0B8
....................        
....................       case MONDAY: 
....................       memcpy(wString,"Mon\0",4); 
0839:  BSF    03.6
083A:  MOVF   12,W
083B:  MOVWF  04
083C:  BCF    03.7
083D:  BTFSC  13.0
083E:  BSF    03.7
083F:  MOVLW  4D
0840:  MOVWF  00
0841:  INCF   04,F
0842:  MOVLW  6F
0843:  MOVWF  00
0844:  INCF   04,F
0845:  MOVLW  6E
0846:  MOVWF  00
0847:  INCF   04,F
0848:  CLRF   00
....................       break; 
0849:  GOTO   0B8
....................        
....................       case TUESDAY: 
....................       memcpy(wString,"Tue\0",4); 
084A:  BSF    03.6
084B:  MOVF   12,W
084C:  MOVWF  04
084D:  BCF    03.7
084E:  BTFSC  13.0
084F:  BSF    03.7
0850:  MOVLW  54
0851:  MOVWF  00
0852:  INCF   04,F
0853:  MOVLW  75
0854:  MOVWF  00
0855:  INCF   04,F
0856:  MOVLW  65
0857:  MOVWF  00
0858:  INCF   04,F
0859:  CLRF   00
....................       break; 
085A:  GOTO   0B8
....................        
....................       case WEDNESDAY: 
....................       memcpy(wString,"Wed\0",4); 
085B:  BSF    03.6
085C:  MOVF   12,W
085D:  MOVWF  04
085E:  BCF    03.7
085F:  BTFSC  13.0
0860:  BSF    03.7
0861:  MOVLW  57
0862:  MOVWF  00
0863:  INCF   04,F
0864:  MOVLW  65
0865:  MOVWF  00
0866:  INCF   04,F
0867:  MOVLW  64
0868:  MOVWF  00
0869:  INCF   04,F
086A:  CLRF   00
....................       break; 
086B:  GOTO   0B8
....................        
....................       case THURSDAY: 
....................       memcpy(wString,"Thu\0",4); 
086C:  BSF    03.6
086D:  MOVF   12,W
086E:  MOVWF  04
086F:  BCF    03.7
0870:  BTFSC  13.0
0871:  BSF    03.7
0872:  MOVLW  54
0873:  MOVWF  00
0874:  INCF   04,F
0875:  MOVLW  68
0876:  MOVWF  00
0877:  INCF   04,F
0878:  MOVLW  75
0879:  MOVWF  00
087A:  INCF   04,F
087B:  CLRF   00
....................       break; 
087C:  GOTO   0B8
....................        
....................       case FRIDAY: 
....................       memcpy(wString,"Fri\0",4); 
087D:  BSF    03.6
087E:  MOVF   12,W
087F:  MOVWF  04
0880:  BCF    03.7
0881:  BTFSC  13.0
0882:  BSF    03.7
0883:  MOVLW  46
0884:  MOVWF  00
0885:  INCF   04,F
0886:  MOVLW  72
0887:  MOVWF  00
0888:  INCF   04,F
0889:  MOVLW  69
088A:  MOVWF  00
088B:  INCF   04,F
088C:  CLRF   00
....................       break; 
088D:  GOTO   0B8
....................        
....................       case SATURDAY: 
....................       memcpy(wString,"Sat\0",4); 
088E:  BSF    03.6
088F:  MOVF   12,W
0890:  MOVWF  04
0891:  BCF    03.7
0892:  BTFSC  13.0
0893:  BSF    03.7
0894:  MOVLW  53
0895:  MOVWF  00
0896:  INCF   04,F
0897:  MOVLW  61
0898:  MOVWF  00
0899:  INCF   04,F
089A:  MOVLW  74
089B:  MOVWF  00
089C:  INCF   04,F
089D:  CLRF   00
....................       break; 
089E:  GOTO   0B8
089F:  BCF    03.6
....................        
....................       default: 
....................       memcpy(wString,"Invalid\0",8); 
08A0:  CLRF   78
08A1:  MOVLW  08
08A2:  MOVWF  77
08A3:  BSF    03.6
08A4:  MOVF   12,W
08A5:  MOVWF  04
08A6:  BCF    03.7
08A7:  BTFSC  13.0
08A8:  BSF    03.7
08A9:  MOVF   78,W
08AA:  BCF    0A.3
08AB:  BCF    03.6
08AC:  CALL   051
08AD:  BSF    0A.3
08AE:  MOVWF  00
08AF:  INCF   78,F
08B0:  INCF   04,F
08B1:  DECFSZ 77,F
08B2:  GOTO   0B4
08B3:  GOTO   0B6
08B4:  BSF    03.6
08B5:  GOTO   0A9
....................       break; 
08B6:  BSF    03.6
08B7:  GOTO   0B8
....................    } 
.................... } 
....................  
.................... /* Formats a given month (as an integer) to a string 
....................  */ 
.................... static void MonthAbbreviations(unsigned int8 month, char* mString) 
.................... { 
....................    switch(month) 
*
08CB:  MOVF   11,W
08CC:  XORLW  00
08CD:  BCF    03.6
08CE:  BTFSC  03.2
08CF:  GOTO   0F2
08D0:  XORLW  01
08D1:  BTFSC  03.2
08D2:  GOTO   103
08D3:  XORLW  03
08D4:  BTFSC  03.2
08D5:  GOTO   114
08D6:  XORLW  01
08D7:  BTFSC  03.2
08D8:  GOTO   125
08D9:  XORLW  07
08DA:  BTFSC  03.2
08DB:  GOTO   136
08DC:  XORLW  01
08DD:  BTFSC  03.2
08DE:  GOTO   147
08DF:  XORLW  03
08E0:  BTFSC  03.2
08E1:  GOTO   158
08E2:  XORLW  01
08E3:  BTFSC  03.2
08E4:  GOTO   169
08E5:  XORLW  0F
08E6:  BTFSC  03.2
08E7:  GOTO   17A
08E8:  XORLW  01
08E9:  BTFSC  03.2
08EA:  GOTO   18B
08EB:  XORLW  03
08EC:  BTFSC  03.2
08ED:  GOTO   19C
08EE:  XORLW  01
08EF:  BTFSC  03.2
08F0:  GOTO   1AD
08F1:  GOTO   1BF
....................    { 
....................       case JANUARY: 
....................       memcpy(mString,"Jan\0",4); 
08F2:  BSF    03.6
08F3:  MOVF   12,W
08F4:  MOVWF  04
08F5:  BCF    03.7
08F6:  BTFSC  13.0
08F7:  BSF    03.7
08F8:  MOVLW  4A
08F9:  MOVWF  00
08FA:  INCF   04,F
08FB:  MOVLW  61
08FC:  MOVWF  00
08FD:  INCF   04,F
08FE:  MOVLW  6E
08FF:  MOVWF  00
0900:  INCF   04,F
0901:  CLRF   00
....................       break; 
0902:  GOTO   1D7
....................        
....................       case FEBRUARY: 
....................       memcpy(mString,"Feb\0",4); 
0903:  BSF    03.6
0904:  MOVF   12,W
0905:  MOVWF  04
0906:  BCF    03.7
0907:  BTFSC  13.0
0908:  BSF    03.7
0909:  MOVLW  46
090A:  MOVWF  00
090B:  INCF   04,F
090C:  MOVLW  65
090D:  MOVWF  00
090E:  INCF   04,F
090F:  MOVLW  62
0910:  MOVWF  00
0911:  INCF   04,F
0912:  CLRF   00
....................       break; 
0913:  GOTO   1D7
....................        
....................       case MARCH: 
....................       memcpy(mString,"Mar\0",4); 
0914:  BSF    03.6
0915:  MOVF   12,W
0916:  MOVWF  04
0917:  BCF    03.7
0918:  BTFSC  13.0
0919:  BSF    03.7
091A:  MOVLW  4D
091B:  MOVWF  00
091C:  INCF   04,F
091D:  MOVLW  61
091E:  MOVWF  00
091F:  INCF   04,F
0920:  MOVLW  72
0921:  MOVWF  00
0922:  INCF   04,F
0923:  CLRF   00
....................       break; 
0924:  GOTO   1D7
....................        
....................       case APRIL: 
....................       memcpy(mString,"Apr\0",4); 
0925:  BSF    03.6
0926:  MOVF   12,W
0927:  MOVWF  04
0928:  BCF    03.7
0929:  BTFSC  13.0
092A:  BSF    03.7
092B:  MOVLW  41
092C:  MOVWF  00
092D:  INCF   04,F
092E:  MOVLW  70
092F:  MOVWF  00
0930:  INCF   04,F
0931:  MOVLW  72
0932:  MOVWF  00
0933:  INCF   04,F
0934:  CLRF   00
....................       break; 
0935:  GOTO   1D7
....................        
....................       case MAY: 
....................       memcpy(mString,"May\0",4); 
0936:  BSF    03.6
0937:  MOVF   12,W
0938:  MOVWF  04
0939:  BCF    03.7
093A:  BTFSC  13.0
093B:  BSF    03.7
093C:  MOVLW  4D
093D:  MOVWF  00
093E:  INCF   04,F
093F:  MOVLW  61
0940:  MOVWF  00
0941:  INCF   04,F
0942:  MOVLW  79
0943:  MOVWF  00
0944:  INCF   04,F
0945:  CLRF   00
....................       break; 
0946:  GOTO   1D7
....................        
....................       case JUNE: 
....................       memcpy(mString,"Jun\0",4); 
0947:  BSF    03.6
0948:  MOVF   12,W
0949:  MOVWF  04
094A:  BCF    03.7
094B:  BTFSC  13.0
094C:  BSF    03.7
094D:  MOVLW  4A
094E:  MOVWF  00
094F:  INCF   04,F
0950:  MOVLW  75
0951:  MOVWF  00
0952:  INCF   04,F
0953:  MOVLW  6E
0954:  MOVWF  00
0955:  INCF   04,F
0956:  CLRF   00
....................       break; 
0957:  GOTO   1D7
....................        
....................       case JULY: 
....................       memcpy(mString,"Jul\0",4); 
0958:  BSF    03.6
0959:  MOVF   12,W
095A:  MOVWF  04
095B:  BCF    03.7
095C:  BTFSC  13.0
095D:  BSF    03.7
095E:  MOVLW  4A
095F:  MOVWF  00
0960:  INCF   04,F
0961:  MOVLW  75
0962:  MOVWF  00
0963:  INCF   04,F
0964:  MOVLW  6C
0965:  MOVWF  00
0966:  INCF   04,F
0967:  CLRF   00
....................       break; 
0968:  GOTO   1D7
....................        
....................       case AUGUST: 
....................       memcpy(mString,"Aug\0",4); 
0969:  BSF    03.6
096A:  MOVF   12,W
096B:  MOVWF  04
096C:  BCF    03.7
096D:  BTFSC  13.0
096E:  BSF    03.7
096F:  MOVLW  41
0970:  MOVWF  00
0971:  INCF   04,F
0972:  MOVLW  75
0973:  MOVWF  00
0974:  INCF   04,F
0975:  MOVLW  67
0976:  MOVWF  00
0977:  INCF   04,F
0978:  CLRF   00
....................       break; 
0979:  GOTO   1D7
....................        
....................       case SEPTEMBER: 
....................       memcpy(mString,"Sep\0",4); 
097A:  BSF    03.6
097B:  MOVF   12,W
097C:  MOVWF  04
097D:  BCF    03.7
097E:  BTFSC  13.0
097F:  BSF    03.7
0980:  MOVLW  53
0981:  MOVWF  00
0982:  INCF   04,F
0983:  MOVLW  65
0984:  MOVWF  00
0985:  INCF   04,F
0986:  MOVLW  70
0987:  MOVWF  00
0988:  INCF   04,F
0989:  CLRF   00
....................       break; 
098A:  GOTO   1D7
....................        
....................       case OCTOBER: 
....................       memcpy(mString,"Oct\0",4); 
098B:  BSF    03.6
098C:  MOVF   12,W
098D:  MOVWF  04
098E:  BCF    03.7
098F:  BTFSC  13.0
0990:  BSF    03.7
0991:  MOVLW  4F
0992:  MOVWF  00
0993:  INCF   04,F
0994:  MOVLW  63
0995:  MOVWF  00
0996:  INCF   04,F
0997:  MOVLW  74
0998:  MOVWF  00
0999:  INCF   04,F
099A:  CLRF   00
....................       break; 
099B:  GOTO   1D7
....................        
....................       case NOVEMBER: 
....................       memcpy(mString,"Nov\0",4); 
099C:  BSF    03.6
099D:  MOVF   12,W
099E:  MOVWF  04
099F:  BCF    03.7
09A0:  BTFSC  13.0
09A1:  BSF    03.7
09A2:  MOVLW  4E
09A3:  MOVWF  00
09A4:  INCF   04,F
09A5:  MOVLW  6F
09A6:  MOVWF  00
09A7:  INCF   04,F
09A8:  MOVLW  76
09A9:  MOVWF  00
09AA:  INCF   04,F
09AB:  CLRF   00
....................       break; 
09AC:  GOTO   1D7
....................        
....................       case DECEMBER: 
....................       memcpy(mString,"Dec\0",4); 
09AD:  BSF    03.6
09AE:  MOVF   12,W
09AF:  MOVWF  04
09B0:  BCF    03.7
09B1:  BTFSC  13.0
09B2:  BSF    03.7
09B3:  MOVLW  44
09B4:  MOVWF  00
09B5:  INCF   04,F
09B6:  MOVLW  65
09B7:  MOVWF  00
09B8:  INCF   04,F
09B9:  MOVLW  63
09BA:  MOVWF  00
09BB:  INCF   04,F
09BC:  CLRF   00
....................       break; 
09BD:  GOTO   1D7
09BE:  BCF    03.6
....................        
....................       default: 
....................       memcpy(mString,"Invalid\0",8); 
09BF:  CLRF   78
09C0:  MOVLW  08
09C1:  MOVWF  77
09C2:  BSF    03.6
09C3:  MOVF   12,W
09C4:  MOVWF  04
09C5:  BCF    03.7
09C6:  BTFSC  13.0
09C7:  BSF    03.7
09C8:  MOVF   78,W
09C9:  BCF    0A.3
09CA:  BCF    03.6
09CB:  CALL   051
09CC:  BSF    0A.3
09CD:  MOVWF  00
09CE:  INCF   78,F
09CF:  INCF   04,F
09D0:  DECFSZ 77,F
09D1:  GOTO   1D3
09D2:  GOTO   1D5
09D3:  BSF    03.6
09D4:  GOTO   1C8
....................       break; 
09D5:  BSF    03.6
09D6:  GOTO   1D7
....................    } 
.................... } 
....................  
.................... /* Determines if a year is a leap year 
....................  * 'year' is the number of years since 1900 
....................  * A year is a leap year if is evenly divisible by 4 while not divisible by 100 
....................  * or if it is evenly divisible by 400. (Ex. 2000 is a leap year, 2100 is not) 
....................  * Returns TRUE if the year is a leap year, FALSE if not 
....................  */ 
.................... static int1 LeapYear(unsigned int16 year) 
.................... { 
....................    if( ((year + 1900) % 400 == 0) ||  
....................        (((year + 1900) % 4 == 0) && ((year + 1900) % 100 != 0)) ) 
*
0441:  MOVLW  6C
0442:  ADDWF  5D,W
0443:  MOVWF  5F
0444:  MOVF   5E,W
0445:  MOVWF  60
0446:  MOVLW  07
0447:  BTFSC  03.0
0448:  MOVLW  08
0449:  ADDWF  60,F
044A:  MOVF   60,W
044B:  MOVWF  62
044C:  MOVF   5F,W
044D:  MOVWF  61
044E:  MOVLW  01
044F:  MOVWF  64
0450:  MOVLW  90
0451:  MOVWF  63
0452:  BCF    03.5
0453:  CALL   2C6
0454:  MOVF   77,W
0455:  BSF    03.5
0456:  MOVWF  5F
0457:  MOVF   7A,W
0458:  MOVWF  60
0459:  MOVF   5F,F
045A:  BTFSS  03.2
045B:  GOTO   45F
045C:  MOVF   60,F
045D:  BTFSC  03.2
045E:  GOTO   48E
045F:  MOVLW  6C
0460:  ADDWF  5D,W
0461:  MOVWF  5F
0462:  MOVF   5E,W
0463:  MOVWF  60
0464:  MOVLW  07
0465:  BTFSC  03.0
0466:  MOVLW  08
0467:  ADDWF  60,F
0468:  MOVLW  03
0469:  ANDWF  5F,F
046A:  CLRF   60
046B:  MOVF   5F,F
046C:  BTFSS  03.2
046D:  GOTO   491
046E:  MOVF   60,F
046F:  BTFSS  03.2
0470:  GOTO   491
0471:  MOVLW  6C
0472:  ADDWF  5D,W
0473:  MOVWF  5F
0474:  MOVF   5E,W
0475:  MOVWF  60
0476:  MOVLW  07
0477:  BTFSC  03.0
0478:  MOVLW  08
0479:  ADDWF  60,F
047A:  MOVF   60,W
047B:  MOVWF  62
047C:  MOVF   5F,W
047D:  MOVWF  61
047E:  CLRF   64
047F:  MOVLW  64
0480:  MOVWF  63
0481:  BCF    03.5
0482:  CALL   2C6
0483:  MOVF   77,W
0484:  BSF    03.5
0485:  MOVWF  5F
0486:  MOVF   7A,W
0487:  MOVWF  60
0488:  MOVF   5F,F
0489:  BTFSS  03.2
048A:  GOTO   48E
048B:  MOVF   60,F
048C:  BTFSC  03.2
048D:  GOTO   491
....................       return TRUE; 
048E:  MOVLW  01
048F:  MOVWF  78
0490:  GOTO   493
....................       
....................    return FALSE; 
0491:  MOVLW  00
0492:  MOVWF  78
.................... } 
....................  
.................... // see time.h for documentation 
.................... signed int32 difftime(time_t later, time_t earlier) 
.................... { 
....................    return (later - earlier); 
.................... } 
....................  
.................... // see time.h for documentation 
.................... time_t mktime(struct_tm * timeT) 
.................... { 
....................    time_t unixTime = 0; 
....................    int1 isLeapYear = FALSE; 
....................    unsigned int16 i = 0; 
....................     
....................    if(timeT != NULL) 
....................    { 
....................     
....................       unixTime += timeT->tm_sec; 
....................       unixTime += (unsigned int32)(timeT->tm_min) * 60; 
....................       unixTime += (unsigned int32)(timeT->tm_hour) * 3600; 
....................        
....................       isLeapYear = LeapYear(timeT->tm_year); 
....................        /* Clamp the month to [0,11) */ 
....................       timeT->tm_mon %= 12; 
....................       for(i = 1;i <= timeT->tm_mon;i++) 
....................       { 
....................          unixTime += (DaysInMonth(i - 1,isLeapYear) * 86400); 
....................       } 
....................        
....................       /* Clamp the days in the month */ 
....................       //timeT->tm_mday %= DaysInMonth(timeT->tm_mon,isLeapYear); 
....................       unixTime += (timeT->tm_mday - 1) * 86400; 
....................        
....................       if(isLeapYear) 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 366; 
....................       } 
....................       else 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 365; 
....................       } 
....................        
....................      #if defined(TIME_T_USES_2010) 
....................       i = 110; 
....................       if(timeT->tm_year - 110 >= 0) 
....................      #else 
....................       i = 70; 
....................       if(timeT->tm_year - 70 >= 0) 
....................      #endif 
....................       { 
....................          while(i < (timeT->tm_year)) 
....................          { 
....................             isLeapYear = LeapYear(i); 
....................             if(isLeapYear) 
....................             { 
....................                unixTime += (31622400); // seconds in 366 days 
....................             } 
....................             else 
....................             { 
....................                unixTime += (31536000); // seconds in 365 days 
....................             } 
....................             i++; 
....................          } 
....................       } 
....................        
....................      #if defined(TIME_T_USES_2010) 
....................       timeT->tm_wday = ((unixTime / 86400) + 5) % 7; 
....................      #else 
....................       timeT->tm_wday = ((unixTime / 86400) + 4) % 7; 
....................      #endif 
....................    } 
....................  
....................    return unixTime; 
.................... } 
....................  
.................... // see time.h for documentation 
.................... char * asctime ( struct_tm * timeptr, char * szTime = 0) 
.................... { 
....................    char result[25]; 
....................  
....................    WeekdayAbbreviations(timeptr->tm_wday, &result[0]); 
*
0800:  MOVLW  07
0801:  BSF    03.5
0802:  ADDWF  52,W
0803:  MOVWF  04
0804:  BCF    03.7
0805:  BTFSC  53.0
0806:  BSF    03.7
0807:  MOVF   00,W
0808:  BCF    03.5
0809:  BSF    03.6
080A:  MOVWF  10
080B:  MOVF   10,W
080C:  MOVWF  11
080D:  CLRF   13
080E:  MOVLW  D6
080F:  MOVWF  12
....................    result[3] = ' '; 
*
08B8:  MOVLW  20
08B9:  BSF    03.5
08BA:  BCF    03.6
08BB:  MOVWF  59
....................    MonthAbbreviations(timeptr->tm_mon, &result[4]); 
08BC:  MOVLW  04
08BD:  ADDWF  52,W
08BE:  MOVWF  04
08BF:  BCF    03.7
08C0:  BTFSC  53.0
08C1:  BSF    03.7
08C2:  MOVF   00,W
08C3:  BCF    03.5
08C4:  BSF    03.6
08C5:  MOVWF  10
08C6:  MOVF   10,W
08C7:  MOVWF  11
08C8:  CLRF   13
08C9:  MOVLW  DA
08CA:  MOVWF  12
....................  
....................    sprintf(&result[7]," %u %02u:%02u:%02u %04lu", 
....................       timeptr->tm_mday, 
....................       timeptr->tm_hour, 
....................       timeptr->tm_min, 
....................       timeptr->tm_sec, 
....................       (timeptr->tm_year + (unsigned int16)1900)); 
*
09D7:  MOVLW  03
09D8:  BSF    03.5
09D9:  BCF    03.6
09DA:  ADDWF  52,W
09DB:  MOVWF  04
09DC:  BCF    03.7
09DD:  BTFSC  53.0
09DE:  BSF    03.7
09DF:  MOVF   00,W
09E0:  BCF    03.5
09E1:  BSF    03.6
09E2:  MOVWF  10
09E3:  MOVLW  02
09E4:  BSF    03.5
09E5:  BCF    03.6
09E6:  ADDWF  52,W
09E7:  MOVWF  04
09E8:  BCF    03.7
09E9:  BTFSC  53.0
09EA:  BSF    03.7
09EB:  MOVF   00,W
09EC:  BCF    03.5
09ED:  BSF    03.6
09EE:  MOVWF  11
09EF:  MOVLW  01
09F0:  BSF    03.5
09F1:  BCF    03.6
09F2:  ADDWF  52,W
09F3:  MOVWF  04
09F4:  BCF    03.7
09F5:  BTFSC  53.0
09F6:  BSF    03.7
09F7:  MOVF   00,W
09F8:  BCF    03.5
09F9:  BSF    03.6
09FA:  MOVWF  12
09FB:  BSF    03.5
09FC:  BCF    03.6
09FD:  MOVF   52,W
09FE:  MOVWF  04
09FF:  BCF    03.7
0A00:  BTFSC  53.0
0A01:  BSF    03.7
0A02:  MOVF   00,W
0A03:  BCF    03.5
0A04:  BSF    03.6
0A05:  MOVWF  13
0A06:  MOVLW  05
0A07:  BSF    03.5
0A08:  BCF    03.6
0A09:  ADDWF  52,W
0A0A:  MOVWF  04
0A0B:  BCF    03.7
0A0C:  BTFSC  53.0
0A0D:  BSF    03.7
0A0E:  INCF   04,F
0A0F:  MOVF   00,W
0A10:  BCF    03.5
0A11:  BSF    03.6
0A12:  MOVWF  15
0A13:  DECF   04,F
0A14:  MOVF   00,W
0A15:  MOVWF  14
0A16:  MOVLW  6C
0A17:  ADDWF  14,F
0A18:  MOVLW  07
0A19:  BTFSC  03.0
0A1A:  MOVLW  08
0A1B:  ADDWF  15,F
0A1C:  BCF    03.6
0A1D:  CLRF   32
0A1E:  MOVLW  DD
0A1F:  MOVWF  31
0A20:  MOVLW  20
0A21:  BSF    03.6
0A22:  MOVWF  1F
0A23:  BCF    0A.3
0A24:  BCF    03.6
0A25:  CALL   638
0A26:  BSF    0A.3
0A27:  BSF    03.6
0A28:  MOVF   10,W
0A29:  MOVWF  16
0A2A:  MOVLW  1B
0A2B:  MOVWF  17
0A2C:  BCF    0A.3
0A2D:  BCF    03.6
0A2E:  CALL   65E
0A2F:  BSF    0A.3
0A30:  MOVLW  20
0A31:  BSF    03.6
0A32:  MOVWF  1F
0A33:  BCF    0A.3
0A34:  BCF    03.6
0A35:  CALL   638
0A36:  BSF    0A.3
0A37:  BSF    03.6
0A38:  MOVF   11,W
0A39:  MOVWF  16
0A3A:  MOVLW  01
0A3B:  MOVWF  17
0A3C:  BCF    0A.3
0A3D:  BCF    03.6
0A3E:  CALL   65E
0A3F:  BSF    0A.3
0A40:  MOVLW  3A
0A41:  BSF    03.6
0A42:  MOVWF  1F
0A43:  BCF    0A.3
0A44:  BCF    03.6
0A45:  CALL   638
0A46:  BSF    0A.3
0A47:  BSF    03.6
0A48:  MOVF   12,W
0A49:  MOVWF  16
0A4A:  MOVLW  01
0A4B:  MOVWF  17
0A4C:  BCF    0A.3
0A4D:  BCF    03.6
0A4E:  CALL   65E
0A4F:  BSF    0A.3
0A50:  MOVLW  3A
0A51:  BSF    03.6
0A52:  MOVWF  1F
0A53:  BCF    0A.3
0A54:  BCF    03.6
0A55:  CALL   638
0A56:  BSF    0A.3
0A57:  BSF    03.6
0A58:  MOVF   13,W
0A59:  MOVWF  16
0A5A:  MOVLW  01
0A5B:  MOVWF  17
0A5C:  BCF    0A.3
0A5D:  BCF    03.6
0A5E:  CALL   65E
0A5F:  BSF    0A.3
0A60:  MOVLW  20
0A61:  BSF    03.6
0A62:  MOVWF  1F
0A63:  BCF    0A.3
0A64:  BCF    03.6
0A65:  CALL   638
0A66:  BSF    0A.3
0A67:  MOVLW  09
0A68:  MOVWF  04
0A69:  BSF    03.6
0A6A:  MOVF   15,W
0A6B:  MOVWF  17
0A6C:  MOVF   14,W
0A6D:  MOVWF  16
....................  
....................    if (szTime) 
*
0AD4:  BSF    03.5
0AD5:  BCF    03.6
0AD6:  MOVF   54,W
0AD7:  IORWF  55,W
0AD8:  BTFSC  03.2
0AD9:  GOTO   306
....................    { 
....................       strcpy(szTime, result); 
0ADA:  BCF    03.5
0ADB:  BSF    03.6
0ADC:  CLRF   13
0ADD:  MOVLW  D6
0ADE:  MOVWF  12
0ADF:  BSF    03.5
0AE0:  BCF    03.6
0AE1:  MOVF   55,W
0AE2:  BCF    03.5
0AE3:  BSF    03.6
0AE4:  MOVWF  11
0AE5:  BSF    03.5
0AE6:  BCF    03.6
0AE7:  MOVF   54,W
0AE8:  BCF    03.5
0AE9:  BSF    03.6
0AEA:  MOVWF  10
0AEB:  MOVF   12,W
0AEC:  MOVWF  04
0AED:  BCF    03.7
0AEE:  BTFSC  13.0
0AEF:  BSF    03.7
0AF0:  MOVF   00,W
0AF1:  MOVWF  14
0AF2:  MOVF   10,W
0AF3:  MOVWF  04
0AF4:  BCF    03.7
0AF5:  BTFSC  11.0
0AF6:  BSF    03.7
0AF7:  MOVF   14,W
0AF8:  MOVWF  00
0AF9:  MOVF   00,F
0AFA:  BTFSC  03.2
0AFB:  GOTO   2FF
0AFC:  INCF   10,F
0AFD:  INCF   12,F
0AFE:  GOTO   2EB
....................       return szTime; 
0AFF:  BSF    03.5
0B00:  BCF    03.6
0B01:  MOVF   54,W
0B02:  MOVWF  78
0B03:  MOVF   55,W
0B04:  MOVWF  79
0B05:  GOTO   30A
....................    } 
....................     
....................    return result; 
0B06:  MOVLW  D6
0B07:  MOVWF  78
0B08:  MOVLW  00
0B09:  MOVWF  79
0B0A:  BCF    03.5
0B0B:  BSF    0A.3
0B0C:  BCF    0A.4
0B0D:  GOTO   39C (RETURN)
.................... } 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // stop in 's1' on a space. 
.................... // return FALSE on match, TRUE on error 
.................... static int1 _time_stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)||(*s1==' ')); 
....................     s1++, s2++) 
....................     if ((*s1 == '\0') || (*s1 == ' ')) 
....................        return(FALSE);   //match 
....................  return(TRUE); //not match 
.................... } 
....................  
.................... // see time.h for documentation 
.................... int1 timeasc(struct_tm *pTm, char *szTime) 
.................... { 
....................    struct_tm tm; 
....................    char str[9]; 
....................     
....................    if (strlen(szTime) > 20) 
....................    { 
....................       if (szTime[3] != ' ')   return(FALSE); 
....................       for (tm.tm_wday=0; tm.tm_wday<7; tm.tm_wday++) 
....................       { 
....................          WeekdayAbbreviations(tm.tm_wday, str); 
....................          if (!_time_stricmp(szTime, str)) 
....................             break; 
....................       } 
....................     
....................       if (tm.tm_wday >= 7) 
....................          return(FALSE); 
....................       szTime += 4; 
....................    } 
....................    else 
....................    { 
....................       tm.tm_wday = 0; 
....................    } 
....................     
....................    if (szTime[3] != ' ')   return(FALSE); 
....................    for (tm.tm_mon=0; tm.tm_mon<12; tm.tm_mon++) 
....................    { 
....................       MonthAbbreviations(tm.tm_mon, str); 
....................       if (!_time_stricmp(szTime, str)) 
....................          break; 
....................    } 
....................    if (tm.tm_mon >= 12) 
....................       return(FALSE); 
....................    szTime += 4; 
....................  
....................    tm.tm_mday = atoi(szTime); 
....................    szTime += 2; 
....................    if (*szTime == ' ') 
....................       szTime += 1; 
....................  
....................    if (szTime[2] != ':')   return(FALSE); 
....................    tm.tm_hour = atoi(szTime); 
....................    szTime += 3; 
....................  
....................    if (szTime[2] != ':')   return(FALSE); 
....................    tm.tm_min = atoi(szTime);    
....................    szTime += 3; 
....................  
....................    if (szTime[2] != ' ')   return(FALSE); 
....................    tm.tm_sec = atoi(szTime); 
....................    szTime += 3; 
....................  
....................    tm.tm_year = atol(szTime) - 1900; 
....................    szTime += 4; 
....................  
....................    if (pTm != NULL) 
....................    { 
....................       memcpy(pTm, &tm, sizeof(tm)); 
....................    } 
....................     
....................    return(*szTime == '\0'); 
.................... } 
....................  
.................... // see time.h for documentation 
.................... char * ctime ( time_t * timer, char *szTime = 0 ) 
.................... { 
....................    return (asctime(localtime(timer),szTime)); 
.................... } 
....................  
.................... /* Global local time variable */ 
.................... struct_tm g_lTime; 
....................  
.................... // see time.h for documenation 
.................... struct_tm * localtime(time_t * timer) 
*
035C:  BCF    5C.0
035D:  BCF    5C.1
.................... { 
....................    time_t timeCounter; 
....................    int1 done = FALSE; 
....................    int1 isLeapYear = FALSE;   //1970 or 2010 is not a leap year 
....................  
....................    if(timer != NULL) 
035E:  MOVF   56,F
035F:  BTFSS  03.2
0360:  GOTO   364
0361:  MOVF   57,F
0362:  BTFSC  03.2
0363:  GOTO   60C
....................    { 
....................       timeCounter = *timer; 
0364:  MOVF   56,W
0365:  MOVWF  04
0366:  BCF    03.7
0367:  BTFSC  57.0
0368:  BSF    03.7
0369:  MOVF   00,W
036A:  MOVWF  58
036B:  INCF   04,F
036C:  MOVF   00,W
036D:  MOVWF  59
036E:  INCF   04,F
036F:  MOVF   00,W
0370:  MOVWF  5A
0371:  INCF   04,F
0372:  MOVF   00,W
0373:  MOVWF  5B
....................      #if defined(TIME_T_USES_2010) 
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 5) % 7;//fill in the weekday 
....................       g_lTime.tm_year = 110; 
....................      #else 
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 4) % 7;//fill in the weekday 
0374:  BCF    03.1
0375:  MOVF   5B,W
0376:  MOVWF  68
0377:  MOVF   5A,W
0378:  MOVWF  67
0379:  MOVF   59,W
037A:  MOVWF  66
037B:  MOVF   58,W
037C:  MOVWF  65
037D:  CLRF   6C
037E:  MOVLW  01
037F:  MOVWF  6B
0380:  MOVLW  51
0381:  MOVWF  6A
0382:  MOVLW  80
0383:  MOVWF  69
0384:  BCF    03.5
0385:  CALL   20E
0386:  MOVF   7A,W
0387:  BSF    03.5
0388:  MOVWF  60
0389:  MOVF   79,W
038A:  MOVWF  5F
038B:  MOVF   78,W
038C:  MOVWF  5E
038D:  MOVF   77,W
038E:  MOVWF  5D
038F:  MOVLW  04
0390:  ADDWF  5D,F
0391:  MOVLW  00
0392:  BTFSC  03.0
0393:  MOVLW  01
0394:  ADDWF  5E,F
0395:  MOVLW  00
0396:  BTFSC  03.0
0397:  MOVLW  01
0398:  ADDWF  5F,F
0399:  MOVLW  00
039A:  BTFSC  03.0
039B:  MOVLW  01
039C:  ADDWF  60,F
039D:  BSF    03.1
039E:  MOVLW  E1
039F:  MOVWF  04
03A0:  BCF    03.7
03A1:  MOVF   60,W
03A2:  MOVWF  68
03A3:  MOVF   5F,W
03A4:  MOVWF  67
03A5:  MOVF   5E,W
03A6:  MOVWF  66
03A7:  MOVF   5D,W
03A8:  MOVWF  65
03A9:  CLRF   6C
03AA:  CLRF   6B
03AB:  CLRF   6A
03AC:  MOVLW  07
03AD:  MOVWF  69
03AE:  BCF    03.5
03AF:  CALL   20E
03B0:  BSF    03.5
03B1:  MOVF   61,W
03B2:  BCF    03.5
03B3:  MOVWF  3C
....................       g_lTime.tm_year = 70;//we are starting in 1970 
03B4:  CLRF   3B
03B5:  MOVLW  46
03B6:  MOVWF  3A
....................      #endif 
....................        
....................       while(!done) 
03B7:  BSF    03.5
03B8:  BTFSC  5C.0
03B9:  GOTO   497
....................       { 
....................          if(timeCounter < (31622400) && isLeapYear) // seconds in 366 days 
03BA:  BTFSC  5B.7
03BB:  GOTO   3CC
03BC:  MOVF   5B,W
03BD:  SUBLW  01
03BE:  BTFSS  03.0
03BF:  GOTO   3E7
03C0:  BTFSS  03.2
03C1:  GOTO   3CC
03C2:  MOVF   5A,W
03C3:  SUBLW  E2
03C4:  BTFSS  03.0
03C5:  GOTO   3E7
03C6:  BTFSS  03.2
03C7:  GOTO   3CC
03C8:  MOVF   59,W
03C9:  SUBLW  84
03CA:  BTFSS  03.0
03CB:  GOTO   3E7
03CC:  BTFSS  5C.1
03CD:  GOTO   3E7
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
03CE:  BCF    03.1
03CF:  MOVF   5B,W
03D0:  MOVWF  68
03D1:  MOVF   5A,W
03D2:  MOVWF  67
03D3:  MOVF   59,W
03D4:  MOVWF  66
03D5:  MOVF   58,W
03D6:  MOVWF  65
03D7:  CLRF   6C
03D8:  MOVLW  01
03D9:  MOVWF  6B
03DA:  MOVLW  51
03DB:  MOVWF  6A
03DC:  MOVLW  80
03DD:  MOVWF  69
03DE:  BCF    03.5
03DF:  CALL   20E
03E0:  MOVF   78,W
03E1:  MOVWF  3E
03E2:  MOVF   77,W
03E3:  MOVWF  3D
....................             break; 
03E4:  BSF    03.5
03E5:  GOTO   497
....................          } 
03E6:  GOTO   417
....................          else if(timeCounter < (31536000)) // seconds in 365 days 
03E7:  BTFSC  5B.7
03E8:  GOTO   3FF
03E9:  MOVF   5B,W
03EA:  SUBLW  01
03EB:  BTFSS  03.0
03EC:  GOTO   417
03ED:  BTFSS  03.2
03EE:  GOTO   3FF
03EF:  MOVF   5A,W
03F0:  SUBLW  E1
03F1:  BTFSS  03.0
03F2:  GOTO   417
03F3:  BTFSS  03.2
03F4:  GOTO   3FF
03F5:  MOVF   59,W
03F6:  SUBLW  33
03F7:  BTFSS  03.0
03F8:  GOTO   417
03F9:  BTFSS  03.2
03FA:  GOTO   3FF
03FB:  MOVF   58,W
03FC:  SUBLW  7F
03FD:  BTFSS  03.0
03FE:  GOTO   417
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
03FF:  BCF    03.1
0400:  MOVF   5B,W
0401:  MOVWF  68
0402:  MOVF   5A,W
0403:  MOVWF  67
0404:  MOVF   59,W
0405:  MOVWF  66
0406:  MOVF   58,W
0407:  MOVWF  65
0408:  CLRF   6C
0409:  MOVLW  01
040A:  MOVWF  6B
040B:  MOVLW  51
040C:  MOVWF  6A
040D:  MOVLW  80
040E:  MOVWF  69
040F:  BCF    03.5
0410:  CALL   20E
0411:  MOVF   78,W
0412:  MOVWF  3E
0413:  MOVF   77,W
0414:  MOVWF  3D
....................             break; 
0415:  BSF    03.5
0416:  GOTO   497
....................          } 
....................           
....................          if(isLeapYear) 
0417:  BTFSS  5C.1
0418:  GOTO   428
....................          { 
....................             timeCounter -= 31622400; // seconds in 366 days 
0419:  MOVLW  00
041A:  SUBWF  58,F
041B:  MOVLW  85
041C:  BTFSS  03.0
041D:  MOVLW  86
041E:  SUBWF  59,F
041F:  MOVLW  E2
0420:  BTFSS  03.0
0421:  MOVLW  E3
0422:  SUBWF  5A,F
0423:  MOVLW  01
0424:  BTFSS  03.0
0425:  MOVLW  02
0426:  SUBWF  5B,F
....................          } 
0427:  GOTO   436
....................          else 
....................          { 
....................             timeCounter -= 31536000; // seconds in 365 days 
0428:  MOVLW  80
0429:  SUBWF  58,F
042A:  MOVLW  33
042B:  BTFSS  03.0
042C:  MOVLW  34
042D:  SUBWF  59,F
042E:  MOVLW  E1
042F:  BTFSS  03.0
0430:  MOVLW  E2
0431:  SUBWF  5A,F
0432:  MOVLW  01
0433:  BTFSS  03.0
0434:  MOVLW  02
0435:  SUBWF  5B,F
....................          } 
....................           
....................          g_lTime.tm_year++; 
0436:  BCF    03.5
0437:  INCF   3A,F
0438:  BTFSC  03.2
0439:  INCF   3B,F
....................          isLeapYear = LeapYear(g_lTime.tm_year); 
043A:  MOVF   3B,W
043B:  BSF    03.5
043C:  MOVWF  5E
043D:  BCF    03.5
043E:  MOVF   3A,W
043F:  BSF    03.5
0440:  MOVWF  5D
*
0493:  BCF    5C.1
0494:  BTFSC  78.0
0495:  BSF    5C.1
0496:  GOTO   3B8
....................       } 
....................        
....................       g_lTime.tm_mon = 0; 
0497:  BCF    03.5
0498:  CLRF   39
....................       while(!done) 
0499:  BSF    03.5
049A:  BTFSC  5C.0
049B:  GOTO   555
....................       {          
....................          if(timeCounter < DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
049C:  MOVLW  00
049D:  BTFSC  5C.1
049E:  MOVLW  01
049F:  MOVWF  5D
04A0:  BCF    03.5
04A1:  MOVF   39,W
04A2:  BSF    03.5
04A3:  MOVWF  5E
04A4:  MOVF   5D,W
04A5:  MOVWF  5F
04A6:  BCF    03.5
04A7:  CALL   2ED
04A8:  BSF    03.5
04A9:  CLRF   5F
04AA:  MOVF   04,W
04AB:  MOVWF  5E
04AC:  BCF    5F.0
04AD:  BTFSC  03.7
04AE:  BSF    5F.0
04AF:  CLRF   64
04B0:  CLRF   63
04B1:  CLRF   62
04B2:  MOVF   78,W
04B3:  MOVWF  61
04B4:  CLRF   68
04B5:  MOVLW  01
04B6:  MOVWF  67
04B7:  MOVLW  51
04B8:  MOVWF  66
04B9:  MOVLW  80
04BA:  MOVWF  65
04BB:  BCF    03.5
04BC:  CALL   32B
04BD:  BSF    03.5
04BE:  MOVF   5E,W
04BF:  MOVWF  04
04C0:  BCF    03.7
04C1:  BTFSC  5F.0
04C2:  BSF    03.7
04C3:  BTFSC  5B.7
04C4:  GOTO   4DB
04C5:  MOVF   5B,W
04C6:  SUBWF  7A,W
04C7:  BTFSS  03.0
04C8:  GOTO   4DD
04C9:  BTFSS  03.2
04CA:  GOTO   4DB
04CB:  MOVF   5A,W
04CC:  SUBWF  79,W
04CD:  BTFSS  03.0
04CE:  GOTO   4DD
04CF:  BTFSS  03.2
04D0:  GOTO   4DB
04D1:  MOVF   59,W
04D2:  SUBWF  78,W
04D3:  BTFSS  03.0
04D4:  GOTO   4DD
04D5:  BTFSS  03.2
04D6:  GOTO   4DB
04D7:  MOVF   77,W
04D8:  SUBWF  58,W
04D9:  BTFSC  03.0
04DA:  GOTO   4DD
....................          { 
....................             break; 
04DB:  GOTO   555
....................          } 
04DC:  GOTO   554
....................          else if(timeCounter >= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
04DD:  MOVLW  00
04DE:  BTFSC  5C.1
04DF:  MOVLW  01
04E0:  MOVWF  5D
04E1:  BCF    03.5
04E2:  MOVF   39,W
04E3:  BSF    03.5
04E4:  MOVWF  5E
04E5:  MOVF   5D,W
04E6:  MOVWF  5F
04E7:  BCF    03.5
04E8:  CALL   2ED
04E9:  BSF    03.5
04EA:  CLRF   5F
04EB:  MOVF   04,W
04EC:  MOVWF  5E
04ED:  BCF    5F.0
04EE:  BTFSC  03.7
04EF:  BSF    5F.0
04F0:  CLRF   64
04F1:  CLRF   63
04F2:  CLRF   62
04F3:  MOVF   78,W
04F4:  MOVWF  61
04F5:  CLRF   68
04F6:  MOVLW  01
04F7:  MOVWF  67
04F8:  MOVLW  51
04F9:  MOVWF  66
04FA:  MOVLW  80
04FB:  MOVWF  65
04FC:  BCF    03.5
04FD:  CALL   32B
04FE:  BSF    03.5
04FF:  MOVF   5E,W
0500:  MOVWF  04
0501:  BCF    03.7
0502:  BTFSC  5F.0
0503:  BSF    03.7
0504:  BTFSC  5B.7
0505:  GOTO   554
0506:  MOVF   7A,W
0507:  SUBWF  5B,W
0508:  BTFSS  03.0
0509:  GOTO   554
050A:  BTFSS  03.2
050B:  GOTO   51C
050C:  MOVF   79,W
050D:  SUBWF  5A,W
050E:  BTFSS  03.0
050F:  GOTO   554
0510:  BTFSS  03.2
0511:  GOTO   51C
0512:  MOVF   78,W
0513:  SUBWF  59,W
0514:  BTFSS  03.0
0515:  GOTO   554
0516:  BTFSS  03.2
0517:  GOTO   51C
0518:  MOVF   77,W
0519:  SUBWF  58,W
051A:  BTFSS  03.0
051B:  GOTO   554
....................          { 
....................             timeCounter -= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400; 
051C:  MOVLW  00
051D:  BTFSC  5C.1
051E:  MOVLW  01
051F:  MOVWF  5D
0520:  BCF    03.5
0521:  MOVF   39,W
0522:  BSF    03.5
0523:  MOVWF  5E
0524:  MOVF   5D,W
0525:  MOVWF  5F
0526:  BCF    03.5
0527:  CALL   2ED
0528:  BSF    03.5
0529:  CLRF   5F
052A:  MOVF   04,W
052B:  MOVWF  5E
052C:  BCF    5F.0
052D:  BTFSC  03.7
052E:  BSF    5F.0
052F:  CLRF   64
0530:  CLRF   63
0531:  CLRF   62
0532:  MOVF   78,W
0533:  MOVWF  61
0534:  CLRF   68
0535:  MOVLW  01
0536:  MOVWF  67
0537:  MOVLW  51
0538:  MOVWF  66
0539:  MOVLW  80
053A:  MOVWF  65
053B:  BCF    03.5
053C:  CALL   32B
053D:  BSF    03.5
053E:  MOVF   5E,W
053F:  MOVWF  04
0540:  BCF    03.7
0541:  BTFSC  5F.0
0542:  BSF    03.7
0543:  MOVF   77,W
0544:  SUBWF  58,F
0545:  MOVF   78,W
0546:  BTFSS  03.0
0547:  INCFSZ 78,W
0548:  SUBWF  59,F
0549:  MOVF   79,W
054A:  BTFSS  03.0
054B:  INCFSZ 79,W
054C:  SUBWF  5A,F
054D:  MOVF   7A,W
054E:  BTFSS  03.0
054F:  INCFSZ 7A,W
0550:  SUBWF  5B,F
....................             g_lTime.tm_mon++; 
0551:  BCF    03.5
0552:  INCF   39,F
0553:  BSF    03.5
....................          } 
0554:  GOTO   49A
....................       }   
....................  
....................       g_lTime.tm_mday = (timeCounter / (86400)); 
0555:  BCF    03.1
0556:  MOVF   5B,W
0557:  MOVWF  68
0558:  MOVF   5A,W
0559:  MOVWF  67
055A:  MOVF   59,W
055B:  MOVWF  66
055C:  MOVF   58,W
055D:  MOVWF  65
055E:  CLRF   6C
055F:  MOVLW  01
0560:  MOVWF  6B
0561:  MOVLW  51
0562:  MOVWF  6A
0563:  MOVLW  80
0564:  MOVWF  69
0565:  BCF    03.5
0566:  CALL   20E
0567:  MOVF   77,W
0568:  MOVWF  38
....................       timeCounter -= (g_lTime.tm_mday * (86400)); 
0569:  BSF    03.5
056A:  CLRF   64
056B:  CLRF   63
056C:  CLRF   62
056D:  BCF    03.5
056E:  MOVF   38,W
056F:  BSF    03.5
0570:  MOVWF  61
0571:  CLRF   68
0572:  MOVLW  01
0573:  MOVWF  67
0574:  MOVLW  51
0575:  MOVWF  66
0576:  MOVLW  80
0577:  MOVWF  65
0578:  BCF    03.5
0579:  CALL   32B
057A:  MOVF   77,W
057B:  BSF    03.5
057C:  SUBWF  58,F
057D:  MOVF   78,W
057E:  BTFSS  03.0
057F:  INCFSZ 78,W
0580:  SUBWF  59,F
0581:  MOVF   79,W
0582:  BTFSS  03.0
0583:  INCFSZ 79,W
0584:  SUBWF  5A,F
0585:  MOVF   7A,W
0586:  BTFSS  03.0
0587:  INCFSZ 7A,W
0588:  SUBWF  5B,F
....................       g_lTime.tm_mday += 1; 
0589:  MOVLW  01
058A:  BCF    03.5
058B:  ADDWF  38,F
....................        
....................       g_lTime.tm_hour = (timeCounter / (3600)); 
058C:  BCF    03.1
058D:  BSF    03.5
058E:  MOVF   5B,W
058F:  MOVWF  68
0590:  MOVF   5A,W
0591:  MOVWF  67
0592:  MOVF   59,W
0593:  MOVWF  66
0594:  MOVF   58,W
0595:  MOVWF  65
0596:  CLRF   6C
0597:  CLRF   6B
0598:  MOVLW  0E
0599:  MOVWF  6A
059A:  MOVLW  10
059B:  MOVWF  69
059C:  BCF    03.5
059D:  CALL   20E
059E:  MOVF   77,W
059F:  MOVWF  37
....................       timeCounter -= ((unsigned int32)g_lTime.tm_hour) * 3600; 
05A0:  BSF    03.5
05A1:  CLRF   60
05A2:  CLRF   5F
05A3:  CLRF   5E
05A4:  BCF    03.5
05A5:  MOVF   37,W
05A6:  BSF    03.5
05A7:  MOVWF  5D
05A8:  MOVF   60,W
05A9:  MOVWF  64
05AA:  MOVF   5F,W
05AB:  MOVWF  63
05AC:  MOVF   5E,W
05AD:  MOVWF  62
05AE:  MOVF   5D,W
05AF:  MOVWF  61
05B0:  CLRF   68
05B1:  CLRF   67
05B2:  MOVLW  0E
05B3:  MOVWF  66
05B4:  MOVLW  10
05B5:  MOVWF  65
05B6:  BCF    03.5
05B7:  CALL   32B
05B8:  MOVF   77,W
05B9:  BSF    03.5
05BA:  SUBWF  58,F
05BB:  MOVF   78,W
05BC:  BTFSS  03.0
05BD:  INCFSZ 78,W
05BE:  SUBWF  59,F
05BF:  MOVF   79,W
05C0:  BTFSS  03.0
05C1:  INCFSZ 79,W
05C2:  SUBWF  5A,F
05C3:  MOVF   7A,W
05C4:  BTFSS  03.0
05C5:  INCFSZ 7A,W
05C6:  SUBWF  5B,F
....................        
....................       g_lTime.tm_min = (timeCounter / 60); 
05C7:  BCF    03.1
05C8:  MOVF   5B,W
05C9:  MOVWF  68
05CA:  MOVF   5A,W
05CB:  MOVWF  67
05CC:  MOVF   59,W
05CD:  MOVWF  66
05CE:  MOVF   58,W
05CF:  MOVWF  65
05D0:  CLRF   6C
05D1:  CLRF   6B
05D2:  CLRF   6A
05D3:  MOVLW  3C
05D4:  MOVWF  69
05D5:  BCF    03.5
05D6:  CALL   20E
05D7:  MOVF   77,W
05D8:  MOVWF  36
....................       timeCounter -= (((unsigned int16)g_lTime.tm_min) * 60); 
05D9:  BSF    03.5
05DA:  CLRF   5E
05DB:  BCF    03.5
05DC:  MOVF   36,W
05DD:  BSF    03.5
05DE:  MOVWF  5D
05DF:  MOVF   5E,W
05E0:  MOVWF  60
05E1:  MOVF   5D,W
05E2:  MOVWF  5F
05E3:  CLRF   62
05E4:  MOVLW  3C
05E5:  MOVWF  61
*
05FA:  MOVF   78,W
05FB:  SUBWF  58,F
05FC:  MOVF   79,W
05FD:  BTFSS  03.0
05FE:  INCFSZ 79,W
05FF:  SUBWF  59,F
0600:  MOVLW  00
0601:  BTFSS  03.0
0602:  MOVLW  01
0603:  SUBWF  5A,F
0604:  MOVLW  00
0605:  BTFSS  03.0
0606:  MOVLW  01
0607:  SUBWF  5B,F
....................       
....................       g_lTime.tm_sec = timeCounter; 
0608:  MOVF   58,W
0609:  BCF    03.5
060A:  MOVWF  35
060B:  BSF    03.5
....................    } 
....................     
....................    return &g_lTime; 
060C:  MOVLW  35
060D:  MOVWF  78
060E:  MOVLW  00
060F:  MOVWF  79
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #ifndef GET_RTC_TICKS 
....................    #use timer(TICK=10ms, BITS=32, ISR) 
*
013A:  MOVF   3F,W
013B:  MOVWF  78
013C:  MOVF   0F,W
013D:  MOVWF  7A
013E:  MOVF   0E,W
013F:  MOVWF  77
0140:  MOVF   0F,W
0141:  SUBWF  7A,W
0142:  BTFSS  03.2
0143:  GOTO   13C
0144:  MOVF   77,W
0145:  BSF    03.5
0146:  BCF    0C.0
0147:  MOVWF  79
0148:  BCF    03.5
0149:  MOVF   3F,W
014A:  SUBWF  78,W
014B:  BTFSC  03.2
014C:  GOTO   157
014D:  MOVF   0F,W
014E:  MOVWF  7A
014F:  MOVF   0E,W
0150:  MOVWF  77
0151:  MOVF   0F,W
0152:  SUBWF  7A,W
0153:  BTFSS  03.2
0154:  GOTO   14D
0155:  MOVF   77,W
0156:  GOTO   158
0157:  MOVF   79,W
0158:  MOVF   7A,W
0159:  MOVWF  77
015A:  MOVF   3F,W
015B:  MOVWF  78
015C:  MOVF   40,W
015D:  MOVWF  79
015E:  MOVF   41,W
015F:  MOVWF  7A
0160:  MOVF   42,W
0161:  BSF    03.5
0162:  MOVWF  56
0163:  RRF    56,F
0164:  RRF    7A,F
0165:  RRF    79,F
0166:  RRF    78,F
0167:  RRF    77,F
0168:  RRF    56,F
0169:  RRF    7A,F
016A:  RRF    79,F
016B:  RRF    78,F
016C:  RRF    77,F
016D:  RRF    56,F
016E:  RRF    7A,F
016F:  RRF    79,F
0170:  RRF    78,F
0171:  RRF    77,F
0172:  RRF    56,F
0173:  RRF    7A,F
0174:  RRF    79,F
0175:  RRF    78,F
0176:  RRF    77,F
0177:  RRF    56,F
0178:  RRF    7A,F
0179:  RRF    79,F
017A:  RRF    78,F
017B:  RRF    77,F
017C:  BSF    0C.0
017D:  BCF    03.5
017E:  RETURN
....................    //if you change the above #use timer() to use ISR, then you need 
....................    //to enable_interrupts(GLOBAL) in order for timer ISR to be triggered. 
....................     
....................    #define GET_RTC_TICKS()       get_ticks() 
....................     
....................    #define CLOCKS_PER_SECOND  TICKS_PER_SECOND 
....................     
....................   #if defined(__PCD__) 
....................    //PCD has global interrupts enabled by default 
....................    #define INIT_RTC_TICKS() 
....................   #else 
....................    //enable interrupts because our #use timer() above is using ISR option. 
....................    #define INIT_RTC_TICKS()   enable_interrupts(GLOBAL) 
....................   #endif 
.................... #endif 
....................  
.................... #ifndef INIT_RTC_TICKS 
.................... #define INIT_RTC_TICKS() 
.................... #endif 
....................  
.................... /* Globals & Resources */ 
.................... static clock_t clock_ticks; 
*
0B41:  CLRF   43
0B42:  CLRF   44
0B43:  CLRF   45
0B44:  CLRF   46
.................... static time_t calendar_time; //seconds since Jan 1, 1970 00:00:00 
0B45:  CLRF   47
0B46:  CLRF   48
0B47:  CLRF   49
0B48:  CLRF   4A
....................  
.................... /* Returns processor time used by program (clock ticks) 
....................  * Ticks occur at a rate specified by CLOCKS_PER_SECOND 
....................  */ 
.................... clock_t clock(void) 
.................... { 
....................    while (((clock_t)GET_RTC_TICKS() - clock_ticks) >= (clock_t)CLOCKS_PER_SECOND) 
*
0191:  CALL   13A
0192:  MOVF   7A,W
0193:  BSF    03.5
0194:  MOVWF  59
0195:  MOVF   79,W
0196:  MOVWF  58
0197:  MOVF   78,W
0198:  MOVWF  57
0199:  MOVF   77,W
019A:  MOVWF  56
019B:  BCF    03.5
019C:  MOVF   43,W
019D:  BSF    03.5
019E:  SUBWF  56,F
019F:  BCF    03.5
01A0:  MOVF   44,W
01A1:  BTFSS  03.0
01A2:  INCFSZ 44,W
01A3:  GOTO   1A5
01A4:  GOTO   1A8
01A5:  BSF    03.5
01A6:  SUBWF  57,F
01A7:  BCF    03.5
01A8:  MOVF   45,W
01A9:  BTFSS  03.0
01AA:  INCFSZ 45,W
01AB:  GOTO   1AD
01AC:  GOTO   1B0
01AD:  BSF    03.5
01AE:  SUBWF  58,F
01AF:  BCF    03.5
01B0:  MOVF   46,W
01B1:  BTFSS  03.0
01B2:  INCFSZ 46,W
01B3:  GOTO   1B5
01B4:  GOTO   1B8
01B5:  BSF    03.5
01B6:  SUBWF  59,F
01B7:  BCF    03.5
01B8:  BSF    03.5
01B9:  MOVF   59,F
01BA:  BTFSS  03.2
01BB:  GOTO   1C6
01BC:  MOVF   58,F
01BD:  BTFSS  03.2
01BE:  GOTO   1C6
01BF:  MOVF   57,F
01C0:  BTFSS  03.2
01C1:  GOTO   1C6
01C2:  MOVF   56,W
01C3:  SUBLW  4B
01C4:  BTFSC  03.0
01C5:  GOTO   1E5
....................    { 
....................       calendar_time += 1; 
01C6:  MOVLW  01
01C7:  BCF    03.5
01C8:  ADDWF  47,F
01C9:  MOVLW  00
01CA:  BTFSC  03.0
01CB:  MOVLW  01
01CC:  ADDWF  48,F
01CD:  MOVLW  00
01CE:  BTFSC  03.0
01CF:  MOVLW  01
01D0:  ADDWF  49,F
01D1:  MOVLW  00
01D2:  BTFSC  03.0
01D3:  MOVLW  01
01D4:  ADDWF  4A,F
....................       clock_ticks += (clock_t)CLOCKS_PER_SECOND; 
01D5:  MOVLW  4C
01D6:  ADDWF  43,F
01D7:  MOVLW  00
01D8:  BTFSC  03.0
01D9:  MOVLW  01
01DA:  ADDWF  44,F
01DB:  MOVLW  00
01DC:  BTFSC  03.0
01DD:  MOVLW  01
01DE:  ADDWF  45,F
01DF:  MOVLW  00
01E0:  BTFSC  03.0
01E1:  MOVLW  01
01E2:  ADDWF  46,F
01E3:  GOTO   191
01E4:  BSF    03.5
....................    } 
....................     
....................    return((clock_t)GET_RTC_TICKS()); 
01E5:  BCF    03.5
01E6:  CALL   13A
01E7:  RETURN
.................... } 
....................  
.................... /* Returns the current calendar time. 
....................  */ 
.................... time_t time(time_t * timer) 
.................... { 
....................    clock(); 
01E8:  CALL   191
....................     
....................    if (!timer) 
01E9:  BSF    03.5
01EA:  MOVF   52,W
01EB:  IORWF  53,W
01EC:  BTFSS  03.2
01ED:  GOTO   202
....................       *timer = calendar_time; 
01EE:  MOVF   53,W
01EF:  MOVWF  7A
01F0:  MOVF   52,W
01F1:  MOVWF  04
01F2:  BCF    03.7
01F3:  BTFSC  53.0
01F4:  BSF    03.7
01F5:  BCF    03.5
01F6:  MOVF   47,W
01F7:  MOVWF  00
01F8:  INCF   04,F
01F9:  MOVF   48,W
01FA:  MOVWF  00
01FB:  INCF   04,F
01FC:  MOVF   49,W
01FD:  MOVWF  00
01FE:  INCF   04,F
01FF:  MOVF   4A,W
0200:  MOVWF  00
0201:  BSF    03.5
....................        
....................    return(calendar_time); 
0202:  BCF    03.5
0203:  MOVF   47,W
0204:  MOVWF  77
0205:  MOVF   48,W
0206:  MOVWF  78
0207:  MOVF   49,W
0208:  MOVWF  79
0209:  MOVF   4A,W
020A:  MOVWF  7A
020B:  BSF    0A.3
020C:  BCF    0A.4
020D:  GOTO   36A (RETURN)
.................... } 
....................  
.................... /* Sets the current calendar time (in seconds) from the given time 
....................  * and resets the timer ticks. 
....................  */ 
.................... void SetTime(struct_tm * nTime) 
.................... {    
....................    calendar_time = mktime(nTime); 
.................... } 
....................  
.................... /* Sets the current calendar time from the given seconds time 
....................  * and resets the timer ticks. 
....................  */ 
.................... void SetTimeSec(time_t sTime) 
.................... {    
....................    calendar_time = sTime; 
.................... } 
....................  
.................... /* Returns the current time as a struct_tm 
....................  */ 
.................... void GetTime(struct_tm *pRetTm) 
.................... { 
....................    struct_tm *p; 
....................     
....................    clock(); 
*
0357:  CALL   191
....................     
....................    p = localtime(&calendar_time); 
0358:  BSF    03.5
0359:  CLRF   57
035A:  MOVLW  47
035B:  MOVWF  56
*
0610:  MOVF   79,W
0611:  MOVWF  55
0612:  MOVF   78,W
0613:  MOVWF  54
....................     
....................    memcpy(pRetTm, p, sizeof(struct_tm)); 
0614:  MOVF   53,W
0615:  MOVWF  57
0616:  MOVF   52,W
0617:  MOVWF  56
0618:  MOVF   55,W
0619:  MOVWF  59
061A:  MOVF   54,W
061B:  MOVWF  58
061C:  MOVLW  0A
061D:  MOVWF  78
061E:  MOVF   58,W
061F:  MOVWF  04
0620:  BCF    03.7
0621:  BTFSC  59.0
0622:  BSF    03.7
0623:  MOVF   00,W
0624:  MOVWF  77
0625:  MOVF   56,W
0626:  MOVWF  04
0627:  BCF    03.7
0628:  BTFSC  57.0
0629:  BSF    03.7
062A:  MOVF   77,W
062B:  MOVWF  00
062C:  INCF   56,F
062D:  BTFSC  03.2
062E:  INCF   57,F
062F:  INCF   58,F
0630:  BTFSC  03.2
0631:  INCF   59,F
0632:  DECFSZ 78,F
0633:  GOTO   61E
0634:  BCF    03.5
0635:  BSF    0A.3
0636:  BCF    0A.4
0637:  GOTO   392 (RETURN)
.................... } 
....................  
....................  
.................... /* Initializes the timer 
....................  * The work is done by #use timer(), so just reset the ticks. 
....................  */ 
.................... void TimeInit(void) 
.................... { 
....................    INIT_RTC_TICKS(); 
*
017F:  MOVLW  C0
0180:  IORWF  0B,F
....................    clock_ticks = GET_RTC_TICKS();  
0181:  CALL   13A
0182:  MOVF   7A,W
0183:  MOVWF  46
0184:  MOVF   79,W
0185:  MOVWF  45
0186:  MOVF   78,W
0187:  MOVWF  44
0188:  MOVF   77,W
0189:  MOVWF  43
....................    calendar_time = 0; 
018A:  CLRF   4A
018B:  CLRF   49
018C:  CLRF   48
018D:  CLRF   47
018E:  BSF    0A.3
018F:  BCF    0A.4
0190:  GOTO   35B (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... void VFGetTime(void) 
.................... { 
....................    struct_tm tm; 
....................     
....................    GetTime(&tm); 
....................     
....................    fprintf(STREAM_USER_UART, "\r\nMinute (0-59): "); 
....................    tm.tm_min = get_Int8Edit(tm.tm_min); 
....................     
....................    fprintf(STREAM_USER_UART, "\r\nHour (0-23): "); 
....................    tm.tm_hour = get_Int8Edit(tm.tm_hour); 
....................  
....................    fprintf(STREAM_USER_UART, "\r\nDay (1-31): "); 
....................    tm.tm_mday += 1; 
....................    tm.tm_mday = get_Int8Edit(tm.tm_mday); 
....................    tm.tm_mday -= 1; 
....................  
....................    fprintf(STREAM_USER_UART, "\r\nMonth (1-12): "); 
....................    tm.tm_mon += 1; 
....................    tm.tm_mon = get_Int8Edit(tm.tm_mon); 
....................    tm.tm_mon -= 1;    
....................     
....................    fprintf(STREAM_USER_UART, "\r\nYear (ex: 2012): "); 
....................    tm.tm_year += 1900; 
....................    tm.tm_year = get_Int16Edit(tm.tm_year); 
....................    tm.tm_year -= 1900; 
....................     
....................    SetTime(&tm); 
.................... } 
....................  
.................... void main(void) 
*
0B0E:  MOVF   03,W
0B0F:  ANDLW  1F
0B10:  MOVWF  03
0B11:  MOVLW  81
0B12:  BSF    03.5
0B13:  MOVWF  19
0B14:  MOVLW  A6
0B15:  MOVWF  18
0B16:  MOVLW  90
0B17:  BCF    03.5
0B18:  MOVWF  18
0B19:  CLRF   32
0B1A:  CLRF   31
0B1B:  CLRF   42
0B1C:  CLRF   41
0B1D:  CLRF   40
0B1E:  CLRF   3F
0B1F:  MOVLW  B5
0B20:  MOVWF  10
0B21:  CLRF   0E
0B22:  CLRF   0F
0B23:  CLRF   0E
0B24:  BCF    0C.0
0B25:  BSF    03.5
0B26:  BSF    0C.0
0B27:  BSF    1F.0
0B28:  BSF    1F.1
0B29:  BSF    1F.2
0B2A:  BCF    1F.3
0B2B:  MOVLW  01
0B2C:  BCF    03.5
0B2D:  MOVWF  34
0B2E:  MOVLW  23
0B2F:  MOVWF  33
0B30:  MOVLW  4A
0B31:  BSF    03.6
0B32:  MOVWF  23
0B33:  MOVLW  01
0B34:  MOVWF  25
0B35:  MOVLW  90
0B36:  MOVWF  24
0B37:  MOVLW  5D
0B38:  BSF    03.5
0B39:  MOVWF  10
0B3A:  CLRF   12
0B3B:  CLRF   11
0B3C:  BCF    03.5
0B3D:  BCF    03.6
0B3E:  BCF    03.7
.................... { 
....................    time_t oldTime, newTime; 
....................    char str[40]; 
....................    struct_tm tm; 
....................    delay_ms(72); 
*
0B49:  MOVLW  48
0B4A:  BSF    03.5
0B4B:  MOVWF  52
0B4C:  BCF    0A.3
0B4D:  BCF    03.5
0B4E:  CALL   0AE
0B4F:  BSF    0A.3
....................    printf("\r\n\nCCS C Compiler ex_time.c example starting\r\n\n"); 
0B50:  MOVLW  96
0B51:  BSF    03.6
0B52:  MOVWF  0D
0B53:  MOVLW  00
0B54:  MOVWF  0F
0B55:  BCF    0A.3
0B56:  BCF    03.6
0B57:  GOTO   0C2
0B58:  BSF    0A.3
....................    TimeInit(); 
0B59:  BCF    0A.3
0B5A:  GOTO   17F
0B5B:  BSF    0A.3
....................     
.................... //!   if (BUTTON_PRESSED()) 
.................... //!   { 
.................... //!      //ask for current time from user and save it RTC 
.................... //!      VFGetTime(); 
.................... //!      fprintf(STREAM_USER_UART, "\r\n\n"); 
.................... //!   } 
....................     
....................    for(;;) 
....................    { 
....................       restart_wdt(); 
0B5C:  CLRWDT
....................        
....................       delay_ms(10); 
0B5D:  MOVLW  0A
0B5E:  BSF    03.5
0B5F:  MOVWF  52
0B60:  BCF    0A.3
0B61:  BCF    03.5
0B62:  CALL   0AE
0B63:  BSF    0A.3
....................        
....................       newTime = time(NULL); 
0B64:  BSF    03.5
0B65:  CLRF   53
0B66:  CLRF   52
0B67:  BCF    0A.3
0B68:  BCF    03.5
0B69:  GOTO   1E8
0B6A:  BSF    0A.3
0B6B:  MOVF   7A,W
0B6C:  MOVWF  52
0B6D:  MOVF   79,W
0B6E:  MOVWF  51
0B6F:  MOVF   78,W
0B70:  MOVWF  50
0B71:  MOVF   77,W
0B72:  MOVWF  4F
....................  
....................       if (oldTime != newTime) 
0B73:  MOVF   4F,W
0B74:  SUBWF  4B,W
0B75:  BTFSS  03.2
0B76:  GOTO   383
0B77:  MOVF   50,W
0B78:  SUBWF  4C,W
0B79:  BTFSS  03.2
0B7A:  GOTO   383
0B7B:  MOVF   51,W
0B7C:  SUBWF  4D,W
0B7D:  BTFSS  03.2
0B7E:  GOTO   383
0B7F:  MOVF   52,W
0B80:  SUBWF  4E,W
0B81:  BTFSC  03.2
0B82:  GOTO   3F3
....................       { 
....................          oldTime = newTime; 
0B83:  MOVF   52,W
0B84:  MOVWF  4E
0B85:  MOVF   51,W
0B86:  MOVWF  4D
0B87:  MOVF   50,W
0B88:  MOVWF  4C
0B89:  MOVF   4F,W
0B8A:  MOVWF  4B
....................  
....................          GetTime(&tm); 
0B8B:  BSF    03.5
0B8C:  CLRF   53
0B8D:  MOVLW  53
0B8E:  MOVWF  52
0B8F:  BCF    0A.3
0B90:  BCF    03.5
0B91:  GOTO   357
0B92:  BSF    0A.3
....................     
....................          asctime(&tm, str); 
0B93:  BSF    03.5
0B94:  CLRF   53
0B95:  MOVLW  53
0B96:  MOVWF  52
0B97:  CLRF   55
0B98:  MOVLW  A0
0B99:  MOVWF  54
0B9A:  BCF    03.5
0B9B:  GOTO   000
....................           
....................          fprintf(STREAM_USER_UART, "\r%s - %lu - %lu", str, newTime, clock()); 
0B9C:  BCF    0A.3
0B9D:  CALL   191
0B9E:  BSF    0A.3
0B9F:  MOVF   7A,W
0BA0:  MOVWF  60
0BA1:  MOVF   79,W
0BA2:  MOVWF  5F
0BA3:  MOVF   78,W
0BA4:  MOVWF  5E
0BA5:  MOVF   77,W
0BA6:  MOVWF  5D
0BA7:  MOVLW  0D
0BA8:  BTFSS  0C.4
0BA9:  GOTO   3A8
0BAA:  MOVWF  19
0BAB:  MOVLW  A0
0BAC:  MOVWF  04
0BAD:  BCF    03.7
0BAE:  BCF    0A.3
0BAF:  GOTO   69D
0BB0:  BSF    0A.3
0BB1:  MOVLW  20
0BB2:  BTFSS  0C.4
0BB3:  GOTO   3B2
0BB4:  MOVWF  19
0BB5:  MOVLW  2D
0BB6:  BTFSS  0C.4
0BB7:  GOTO   3B6
0BB8:  MOVWF  19
0BB9:  MOVLW  20
0BBA:  BTFSS  0C.4
0BBB:  GOTO   3BA
0BBC:  MOVWF  19
0BBD:  MOVLW  41
0BBE:  MOVWF  04
0BBF:  MOVF   52,W
0BC0:  BSF    03.5
0BC1:  MOVWF  59
0BC2:  BCF    03.5
0BC3:  MOVF   51,W
0BC4:  BSF    03.5
0BC5:  MOVWF  58
0BC6:  BCF    03.5
0BC7:  MOVF   50,W
0BC8:  BSF    03.5
0BC9:  MOVWF  57
0BCA:  BCF    03.5
0BCB:  MOVF   4F,W
0BCC:  BSF    03.5
0BCD:  MOVWF  56
0BCE:  BCF    0A.3
0BCF:  BCF    03.5
0BD0:  CALL   70E
0BD1:  BSF    0A.3
0BD2:  MOVLW  20
0BD3:  BTFSS  0C.4
0BD4:  GOTO   3D3
0BD5:  MOVWF  19
0BD6:  MOVLW  2D
0BD7:  BTFSS  0C.4
0BD8:  GOTO   3D7
0BD9:  MOVWF  19
0BDA:  MOVLW  20
0BDB:  BTFSS  0C.4
0BDC:  GOTO   3DB
0BDD:  MOVWF  19
0BDE:  MOVLW  41
0BDF:  MOVWF  04
0BE0:  MOVF   60,W
0BE1:  BSF    03.5
0BE2:  MOVWF  59
0BE3:  BCF    03.5
0BE4:  MOVF   5F,W
0BE5:  BSF    03.5
0BE6:  MOVWF  58
0BE7:  BCF    03.5
0BE8:  MOVF   5E,W
0BE9:  BSF    03.5
0BEA:  MOVWF  57
0BEB:  BCF    03.5
0BEC:  MOVF   5D,W
0BED:  BSF    03.5
0BEE:  MOVWF  56
0BEF:  BCF    0A.3
0BF0:  BCF    03.5
0BF1:  CALL   70E
0BF2:  BSF    0A.3
....................           
.................... //!        #if defined(__LCD_C__) 
.................... //!         //by using &str[4], we skip the day portion of asctime() 
.................... //!         printf(lcd_putc, "\aCCS ex_time.c\n%s\n", &str[4]); 
.................... //!        #endif 
....................       } 
0BF3:  GOTO   35C
....................    } 
.................... } 
0BF4:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
